/*	Name: TwoPhotonControl.cpp
	Description: Master container class for two photon
	Written by: Alex Greis
	
	Functional Optical Imaging Laboratory
	Department of Biomedical Engineering
	University of Texas at Austin
	Austin, TX 78712

	Created:	9/11/2009
	Updated:
*/ 

#include "TwoPhotonControl.h"
#include <QInputDialog>
#include <QTimer>
#include <QDir>
#include "string.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "time.h"

//include 2p files for functionality
#include "2pData.h"
#include "acqengine.h"
#include "aomControl.h"
#include "scanengine.h"
#include "lifetimeacq.h"
#include "AcqThread.h"
#include "stepperDriver.h"
#include "zStepDriver.h"
#include <QTreeWidget>
#include <QInputDialog>
#include "Server.h"

/*
	NI DAQ Board Configurations (Default)

	X-galvo scan:		/dev1/ao0
	Y-galvo scan:		/dev1/ao1
        AOM Ctrl:		/dev1/ao2
	AOM Ref Out:		/dev1/ao3

        CH1 PMT:		/dev1/ai0
        CH2 PMT:		/dev1/ai1

	TCSPC Trigger:		/dev1/PFI1


*/

/*	=====================================================================================================
		Version Info:
		
		This information is important to the functioning of the read_2p() MATLAB script that
		is used to read image data generated by this program. Version number is used to ensure
		that the MATLAB script can read the data correctly.

		v2.0000			First port to Qt. Starting point for data format.

		v2.0001			Mag field in header is now written as 64 chars. Previously
						this was (erroneously) written as a float32.
						

	=====================================================================================================
*/

// Global Vars & Constants ------------------------------------------------------
double          MaxVolts_X = 5.5;	//max allowable volts for x-galvos
double          MinVolts_X = -5.5;	//max allowable volts for x-galvos
const double	TwoPhotonControl::SCANENGINE_PERCENT_OVERSCAN = 0.10;
const double	TwoPhotonControl::SCANENGINE_PERCENT_OVERSCAN_V = 0.05;
const float     TwoPhotonControl::Version_Number = 2.0001;	//****SEE ABOVE VERSION INFO
const double	TwoPhotonControl::Num_XYSteps_Per_Micron = 0.6333;
const char      TwoPhotonControl::TCSPC_Trig_Channel[] = "/Dev3/port0/line1";	//"/Dev1/ao3";		//To start TCSPC board measurement
const char      TwoPhotonControl::Trig_Channel[] = "/Dev3/port0/line1";
TaskHandle      digTaskHandle1;		//Task handle for sample clock task.
const int       TwoPhotonControl::LIFETIME_REPEAT_NUM = 5;

// -----------------------------------------------------------------------------

//Function: TwoPhotonControl
//Type: Constructor (Default)
//Description: Default constructor
TwoPhotonControl::TwoPhotonControl(QObject * parent) : QObject(parent)
{
	lifeTimeAcqNumber = 1;
        //init();
}


//Function: init
//Type: Member Function
//Description: Initializes application class
//Returns: 1 for success
int TwoPhotonControl::init()
{


        //define class instances
        data2P = new DataFile2P(Min_Count,Max_Count,ADC_Num_Bits,Version_Number);
        acqEng = new AcqEngine(Num_Lines_Flyback);
        aomCtrl = new AomControl;
        scanEng = new ScanEngine(Num_Lines_Flyback,SCANENGINE_PERCENT_OVERSCAN,SCANENGINE_PERCENT_OVERSCAN_V);
        stepEng = new stepperDriver;
        zStepEng = new zStepperDriver;

        //must initialize aom control, since it by default updates output
        aomCtrl->initAomCtrl();

        //initialize class instances
        emit sigUpdateDataFile();
        emit sigUpdateAcqEng();
        emit sigUpdateAomControl();
        emit sigUpdateScanEng();
        emit sigUpdateZStepEng();

        //set up server
        tcspcServer = new Server();
        connect(tcspcServer,SIGNAL(sendPort(int)),this,SLOT(slotSendPort(int)));
        tcspcServer->init();

        //parse config
        ParseConfig();

        //setup aomTimer, connect to slot
        aomTimer = new QTimer();
        connect(aomTimer, SIGNAL(timeout()), this, SLOT(updateAomTimer()));

        //setup scanTimer, connect to slot
        scanTimer = new QTimer();
        connect(scanTimer,SIGNAL(timeout()),this, SLOT(updateScanBar()));
        scanPercent = -1;

        //Init dangling pointers.
        acqEng->setAcqData(NULL);
        scanEng->setDacData(NULL);
        data2P->setPtrData(NULL);

        //open connections for VXM stepper
        if(!stepEng->LoadVXMDriver())
                emit sendMessageForPopup("Error","Velmex VXM Motor Controller drivers not detected.\n"
                                                                                "Make sure driver files are located in program directory.\n\n"
                                                                                "Copy drivers to program directory and restart program.");
        if(!stepEng->openSerialPort())
                emit sendMessageForPopup("Error","Velmex VXM Motor Controller hardware not detected.\n"
                                                                                "VXM controller must be connected to Serial Port.\n\n"
                                                                                "Connect hardware and reconnect in harware config tab.");

        acqThread = new AcqThread(ADC_Num_Bits,Min_Count,Max_Count,Version_Number,scanEng,acqEng,data2P,zStepEng,aomCtrl);
        acqThread->setNIVisionContourInfo(this->NIVisionContourArray[0]);

        //Connect to acqThread
        connect(acqThread,SIGNAL(acqFinished()),this,SLOT(stopAcq()));
        connect(acqThread,SIGNAL(acqFinished()),this,SLOT(acqFinished()));
        connect(acqThread,SIGNAL(sendProgress(double)),this,SLOT(progressUpdate(double)));
        connect(acqThread,SIGNAL(sigZPosChange(double)),this,SLOT(zPosUpdate(double)));


        acqEng->initAcq(false,false);
        //aomCtrl->initAomCtrl();
        scanEng->initScan(false,false);

        zStepEng->setInitialized(false);
        acqEng->setBInitialized(false);
        acqEng->setMemIsAllocated(0);
        scanEng->setBInitialized(false);
        scanEng->setMemIsAllocated(0);
        //aomCtrl->setInitialized(false);

        //Open connections for zStepEng
        if(!zStepEng->Init())
                emit sendMessageForPopup("Error","Z-Stepper Motor hardware not connected.\n"
                                                                                "Motor controller must be connected to Serial Port.\n\n"
                                                                                "Connect hardware and reconnect.");

        //Load log file
        InitLog();

        //Start AOM
        AomZeroStart();

        digTaskHandle1=0;

        return 1;
}


//Function: ~TwoPhotonControl
//Type: Destructor
//Description: Destructor
TwoPhotonControl::~TwoPhotonControl()
{
	//Turn off Aom
	AomStop();

        delete data2P;
        delete acqEng;
        delete aomCtrl;
        delete scanEng;
        delete stepEng;
        delete zStepEng;
        delete acqThread;
}
//Function: startScanBar
//Type: Member Function
//Description: activates scan progress indication
int TwoPhotonControl::startScanBar()
{
	scanPercent = 0;
	scanTimer->start(250);

	return 1;
}






//Function: RotateGalvos
//Type: Slot
//Description: initiates routine to drive galvos to rotate themselves. This is to
//	prevent wear on the galvanometers
void TwoPhotonControl::rotateGalvos()
{
	int retVal;
	int voltNotExceeded = 1;
	
	//Allocate memory

	retVal = scanEng->releaseMemory();
	
	//Grab memory for x waveform
	scanEng->grabRotateMemory();

	//stop any scanning - parkBeam
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	AddLogItem("Galvos Rotation Started");

	//this->updateScanEng();
	//scanEng->initScan(true,false);
	voltNotExceeded = scanEng->generateRotationWaveforms();

	if(!voltNotExceeded)
	{
		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
										"Use lower voltages or less overscan\n");
		return;
	}

	scanEng->setOverscanCalculated(false);
	scanEng->configDAQmxTask(false, false);
	scanEng->setNumSampsTotal(1000);			//because config will calculate this based on xsamps,ysamps, etc.
	scanEng->writeDAQmxTask();
	
	//Start tasks in correct order.
	scanEng->startDAQmxTask();
			

}
//Function: stopScanBar
//Type: Member Function
//Description: deactivates scan progress indication
int TwoPhotonControl::stopScanBar()
{
	scanTimer->stop();
	emit sigUpdateScanBar(0);

	return 1;
}

//----------------------------------------------------------------------------------------
//	Slots --------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
//Function: updateScanBar
//Description: updates scan bar during galvo scanning
void TwoPhotonControl::updateScanBar()
{
	if(scanPercent >= 1)
		scanPercent = 0;
	else
		scanPercent = scanPercent + .05;

	emit sigUpdateScanBar(scanPercent);
}
//Function: Acquire
//Type: Slot
//Description: Called whenever "Acquire" is pressed. Calls functions in order to acquire 2P data and scan
//void TwoPhotonControl::Acquire()
//{
//	//stop any scanning - parkBeam
//	scanEng->stopDAQmxTask();
//	scanEng->clearDAQmxTask();


//	if(!testXVoltageRange(false,scanEng->getOverscan()))
//	{
//		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
//								"Use lower voltages or less overscan\n");
//		return;
//	}

	//start acquisition
//	AddLogItem("Acquisition Started");
//	if(updateLineRateField()<2000)
//	{
//		startScanBar();
//		AcqDriveThread(false);
//	}
//	else
//	{
//		AddLogItem("ERROR: Scan rate too high");
//		emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
//	}
//}
//Function: ScanDrive
//Type: Slot
//Description: Called whenever "Scan" is pressed.No acquisition, only scanning. Starts scan, user must press stop to stop scan.
void TwoPhotonControl::ScanDrive()
{
	int voltNotExceeded = 1;


	//stop any scanning - parkBeam
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	AddLogItem("Continuous Scan Started");
	if(updateLineRateField()<2000)
	{
		//this->updateScanEng();
		scanEng->initScan(true,false);
		voltNotExceeded = scanEng->generateWaveForms();

		if(!voltNotExceeded)
		{
			emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
											"Use lower voltages or less overscan\n");
			return;
		}

		scanEng->setOverscanCalculated(false);
		scanEng->configDAQmxTask(false, true);
		scanEng->writeDAQmxTask();
				
		//SetCtrlVal(appState->panelHandle,PANEL_ledRunning,1); NEED IMPLEMENTATION
		//ProcessDrawEvents();

		//Setup the task which generates the sample clock.
		DAQmxCreateTask("SampleClockTask",&(digTaskHandle1));
		DAQmxCreateCOPulseChanFreq (digTaskHandle1, "/Dev1/ctr1", "SampleClock", DAQmx_Val_Hz, DAQmx_Val_Low,
																	0.1, scanEng->getSamp_Rate(), 0.5);
		DAQmxCfgImplicitTiming(digTaskHandle1,DAQmx_Val_ContSamps ,scanEng->getNumSampsPerFrame());

		//Start tasks in correct order.
		scanEng->startDAQmxTask();
		DAQmxStartTask(digTaskHandle1); 
			
		//Set Scan/Stop buttons
		emit setScanButton(false);
		emit setStopButton(true);
		//lock gui controls for scanning
		emit sigLockControlWidgets();
		emit setStopAcqButton(false);

		startScanBar();
	}
	else
	{
		AddLogItem("ERROR: Scan rate too high");
		emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
	}
}


void TwoPhotonControl::changeDir()
{}
//Function: AcqLifetimeData
//Type: Slot
//Description: Acquires lifetime data defined on previous image by NI open contour tools
void TwoPhotonControl::AcqLifetimeData()
{
//	ContourInfo2*	contourInfo;
//	int		contourType;
        int		NumPts;
        int		totNumPts;
        int		i;
        int		j;
        int		l;
        int		k=0;
        int		lastIndex = 0;
//	int		foo;
        int		x, y;
        int		retVal;
        double		xVolts,yVolts;
        char		txtFileName[1024];
//	char		dataFileName[1024];
        char		temp[1024];
        char		temp1[1024];
        char		temp3[1024];
        int		nameLength;
//	bool		bMemAllocated = false;
//	ofstream	outStream;					NEED IMPLEMENTATION
//	double		xConversionFactor;
//	double		galvoLagTime = acqEng->getXOffset() / acqEng->getDToARate();			//Seconds
                                //number of contours+1 drawn on screen
	ContourInfo2*	tempContour;
	std::ofstream	outStream;
        double		aomOnVoltage = 0.0;
        bool		ok;
	LifetimeAcq*	LTAcqPts = NULL;
        QDir            tempDir;
        QString         tempQString;


	//stop any scanning - parkBeam
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

        if(!NIVisionContourArray[0])
	{
            emit sendMessageForPopup("Error","No Data Points Defined");
            goto Error;
	}
        if ((NIVisionContourArray[0]->type != IMAQ_OPEN_CONTOUR)&&(NIVisionContourArray[0]->type != IMAQ_POINT))
        {
            emit sendMessageForPopup("Error","Points must be defined with open contour or point tool!");
            goto Error;
	}
	
	AddLogItem("Lifetime Acquisition Started");
	
        //set pulsed, nonContinuous AOM
	emit setChkAomPulsed(true);
	emit setChkAomCont(false);

	//calculate the total number of points across all contours
        numContours = 0;
        for(l=0; l < 200; l++)
        {
            if ((NIVisionContourArray)[l])
            {
                numContours++;
            }
        }

	totNumPts = 0;
        for(i = 0; i < numContours; i++)
	{		
            tempContour = (NIVisionContourArray)[i];
            if (tempContour->type == IMAQ_OPEN_CONTOUR)
                totNumPts+= tempContour->structure.openContour->numPoints;
            else if (tempContour->type == IMAQ_POINT)
                totNumPts++;
	}

	//Create structure to hold ROI point information.  This info will be used in
	// a text file which will document where on the image the life time data came
	// from
	LTAcqPts = new LifetimeAcq[totNumPts];
	
        //Take an image and save it for reference.
	if(!testXVoltageRange(false,scanEng->getOverscan()))
	{
            emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
								"Use lower voltages or less overscan\n");
            return;
	}
	if(updateLineRateField()>2500)
	{
            emit sendMessageForPopup("Error","Scan rate cannot go above 2.5KHz\n");
            return;
	}
        data2P->setLifetimeAcq(true); //Saves data in ./Lifetime_Data subfolder

        emit sigChkSave(true);
        emit sigUpdateDataFile();
	emit sigUpdateAcqEng();
	emit sigUpdateScanEng();
	UpdateLineScanSpeed();
	//emit sigUpdateZStepEng();
	emit sigUpdateAomControl();

	//lock some GUI Widgets during acquisition
        QCoreApplication::processEvents();
        emit sigLockControlWidgets();

        //Create Lifetime_Data Dir if it doesnt already exist.
        tempQString = data2P->getOutputDir2Path();
        tempQString.append("/Lifetime_Data/");
        tempDir.setPath(tempQString);
        if (!tempDir.exists())
        {
            tempDir.mkdir(tempDir.absolutePath());
        }

	acqThread->exit();
	acqThread->init(scanEng,acqEng,data2P,zStepEng,aomCtrl);
	acqThread->setLinescan(false);
	acqThread->setContinuous(false);
	acqThread->setLifetimeFov(true);
        acqThread->start();	//This acquires data
	acqThread->wait(ULONG_MAX);


	
	//Prepare TCSPC Client for acquisition ---------------------
	//tcspcServer->setData("Acq");

        //-----------------------------------------------------------
		
	//Ask user what voltage to use for the AOM.
        ok = false;     //Used for bounds checking in dialog box
        while(!ok)      //Why is this while loop here?
	{
            aomOnVoltage = QInputDialog::getDouble(0,tr("AOM On Voltage"),tr("Aom On Voltage:"), 0.0, -2.20, 2.20, 2, &ok);
            if(!ok)
            {
                emit sendMessageForPopup("Error","Invalid Aom Voltage");
                return;
            }
	}
	
        //Process all qued system events in this thread to keep gui going
        QCoreApplication::processEvents();


        //Cycle through all points on all countours
        for(l = 0; l < numContours; l++)
	{  
            NumPts = 0;
            tempContour = (NIVisionContourArray)[l];
            if (tempContour->type == IMAQ_OPEN_CONTOUR)
            {
                NumPts = tempContour->structure.openContour->numPoints;
            }
            else if (tempContour->type == IMAQ_POINT)
            {
                NumPts = 1;
            }
            //Cycle through all points on each contour
            for(i = 0; i < NumPts; i++)
            {
                //Output message to log that lifetime data is being acquired
                sprintf(temp1,"Acquiring lifetime data for contour %i , point %i.",l,i+1);
                AddLogItem(temp1);
                QCoreApplication::processEvents();
                if (tempContour->type == IMAQ_OPEN_CONTOUR)
                {
                    x=tempContour->structure.openContour->points[i].x;
                    y=tempContour->structure.openContour->points[i].y;
                }
                else if (tempContour->type == IMAQ_POINT)
                {
                    x = tempContour->structure.point->x;
                    y = tempContour->structure.point->y;
                }

                //Calc x an y galvo voltage levels which correspond to the selected points
                retVal = CalcXYVoltsFromPxlVal(x, y, xVolts, yVolts);

                //sprintf(str, "(%i,%i)",x, y);
                LTAcqPts[i+lastIndex].setX(x);
                LTAcqPts[i+lastIndex].setY(y);
                LTAcqPts[i+lastIndex].setXVolts((float)xVolts);
                LTAcqPts[i+lastIndex].setYVolts((float)yVolts);
                LTAcqPts[i+lastIndex].setMeasRefNum(lifeTimeAcqNumber);;
                //Acquire and save lifetime data for current point.
                //Concat file name.
/*		{strcpy(dataFileName, temp);
                dataFileName[strlen(dataFileName)-4] = '\0';			//chop off the .dat suffix
                sprintf(temp3,"_LifeTime_%i.dat",k+1);					//
                strcat(dataFileName,temp3);							//Concat lifetime number.
                k++;

                //		-Old analog method (non photon-counting)
                //retVal = LifetimeAcq(xVolts, yVolts, scanStruct,dataFileName);

                //status = ConfigDAQmxTasks(xVolts, yVolts, scanStructure);
                //DAQmxStartTask(aoTaskHandle);
        }
*/                
                //New photon-counting method.  Acq happens on other computer with B&H board
                for (int repeatCounter = 0; repeatCounter < TwoPhotonControl::LIFETIME_REPEAT_NUM ;repeatCounter++)
                {
                    sprintf(temp3," Point # %i ",k+repeatCounter); //Not really used since other computer saves file.  No need for setting name here
                    retVal = AcqLifeTime1Point((float)xVolts, (float)yVolts,aomOnVoltage, temp3);
                }

                //Read B&H lifetime acq files.  Have to assume a Dir and file structure
                //---------NEEDS IMPLEMENTATION------------
            }
            lastIndex=i+lastIndex;
	}

	//Write out structure data to txt file.	
        //data2P->GenFileName(1);	//chan num 1?
        strcpy_s(temp, acqThread->getFileName());
	nameLength = strlen(temp);
	strncpy(txtFileName,temp,nameLength - 3);
	txtFileName[nameLength-3]='\0';
	strcat(txtFileName,"txt");	
	outStream.open(txtFileName, std::ios::out);
        outStream << "Associated Image File Name " << temp << ".\n";
        outStream << "Num_Contours = " << numContours << "\n";
        outStream << "Num_Points = " << totNumPts << "\n";

	lastIndex = 0;
        for(j = 0; j < numContours; j++)
	{	
            NumPts = 0;
            tempContour =(NIVisionContourArray)[j];
            if (tempContour->type == IMAQ_OPEN_CONTOUR)
                NumPts = tempContour->structure.openContour->numPoints;
            else if (tempContour->type == IMAQ_POINT)
                NumPts = 1;

            outStream << "\n<Contour #" << j <<">\n";
            outStream << "Contour #" << j << " contains " << NumPts <<" points.\n";

            outStream << "Acq#\t X\t Y\t X_Volts\t Y_Volts\n";
            for(i = 0; i < NumPts; i++)
            {
                outStream << LTAcqPts[i+lastIndex].getMeasRefNum() << " \t ";
                outStream << LTAcqPts[i+lastIndex].getX() << " \t ";
                outStream << LTAcqPts[i+lastIndex].getY() << " \t ";
                outStream << LTAcqPts[i+lastIndex].getXVolts() << " \t ";
                outStream << LTAcqPts[i+lastIndex].getYVolts() << "\n";
            }
            lastIndex = i + lastIndex;
            //insert a -1 between contours
            //if(j != numContours)
            //    outStream << "-1 , -1 , -1 , -1\n";
            outStream << "</Contour #" << j <<">\n";
	}
	outStream.close();
	
	if (LTAcqPts)
	{
            delete [] LTAcqPts;
            LTAcqPts = NULL;
	}

        //Return checkboxed to nominal state
        //set pulsed, nonContinuous AOM
        emit setChkAomPulsed(false);
        emit setChkAomCont(true);
        emit sigChkSave(false);

        return;

Error:

	if (LTAcqPts)
	{
            delete LTAcqPts;
            LTAcqPts = NULL;
	}
	emit sendMessageForPopup("DAQmx Error","Problem Acquiring Lifetime Data!");

        //Return checkboxed to nominal state
        //set pulsed, nonContinuous AOM
        emit setChkAomPulsed(false);
        emit setChkAomCont(true);
        emit sigChkSave(false);
	
}
//Function: StopScanDrive
//Type: Slot
//Description: Called whenever "Stop" is pressed.Stops Scanning initiated by ScanDrive
void TwoPhotonControl::StopScanDrive()
{
	AddLogItem("Continuous Scan Stopped");
	//Reset Scan/Stop buttons
	emit setScanButton(true);
	emit setStopButton(false);

	

	//unlock gui controls for scanning
	emit sigUnlockControlWidgets();

	scanEng->stopDAQmxTask();
	if (digTaskHandle1 != 0)
	{
		DAQmxStopTask(digTaskHandle1);
		DAQmxClearTask(digTaskHandle1);
		digTaskHandle1 = 0;
	}
	//SetCtrlVal(appState->panelHandle,PANEL_ledRunning,0); NEED IMPLEMENTATION
	acqEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();
	scanEng->setScanTaskHandle(0);
	
	stopScanBar();
}


//Function: AomControlOn
//Type: Slot
//Description: If user enables Aom Control
void TwoPhotonControl::AomControlOn(double voltage)
{
	int retVal;

	aomCtrl->setAomVoltage(voltage);
	aomCtrl->setAomOn(true);

	//restart Aom task with new voltage
	retVal = aomCtrl->stopDAQmxTask();
	retVal = aomCtrl->clearDAQmxTask();
	//retVal = aomCtrl->makeWaveform();  config automatically calls makeWaveform
	retVal = aomCtrl->configNiDAQ();
	retVal = aomCtrl->updateWaveform();
	retVal = aomCtrl->startDAQmxTask();
	
	
	if (aomCtrl->getAomContinuous())
	{
		//For continuous Aom operation, disable timer
		aomTimer->stop();
	}
	else
	{
		//If not continuous, reset timer and start - will trigger updateAomTimer when time is expired
		aomTimer->singleShot(aomCtrl->getAomOnDuration()*1000, this, SLOT(updateAomTimer()));			//aomTimer is in ms, *1000 for seconds
	}
	
	//SetCtrlVal (panel, PANEL_aomLed, 1);	NEED IMPLEMENTATION
	emit setAomOnButton(false);
	emit setAomOffButton(true);

	AddLogItem("AOM Control Enabled");
}




//Function: AomControlUpdate
//Type: Slot
//Description: If user changed AOM voltage amp value, and aom control is on, change output value
void TwoPhotonControl::AomControlUpdate(double voltage)
{
	aomCtrl->setAomVoltage(voltage);

	//If AOM is on, change value and update output voltage of AOMControl task
	if (aomCtrl->getAomOn())
	{
		AomControlOn(voltage);
	}
}

//Function: AomControlOff
//Type: Slot
//Description: If user turns Aom control off (sets it to zero voltage)
void TwoPhotonControl::AomControlOff()
{
	//store pulsed config
	bool pulsed = aomCtrl->getAomPulsed();

	AomStop();
	aomCtrl->setAomPulsed(false);
	AomZeroStart();

	//SetCtrlVal (panel, PANEL_aomLed, 0); NEED IMPLEMENTATION

	emit setAomOnButton(true);
	emit setAomOffButton(false);

	aomCtrl->setAomOn(false);
	AddLogItem("AOM Control Disabled");

	//restore pulsed config
	aomCtrl->setAomPulsed(pulsed);
}
//Function: UpdateScalingField
//Type: Slot
//Description: Updates resolution and scaling fields
void TwoPhotonControl::updateScalingField()
{
	double xVoltRange, yVoltRange;
	double xFov, yFov;

	//Update resolution and field of view
	xVoltRange = scanEng->getXMaxVolts() - scanEng->getXMinVolts();
	yVoltRange = scanEng->getYMaxVolts() - scanEng->getYMinVolts();

	xFov = xVoltRange*scanEng->getScaling();	// um = V*(um/V)
	yFov = yVoltRange*scanEng->getScaling();	// um = V*(um/V)

	//Update GUI
	emit sigUpdateScalingFields((int)xFov,(int)yFov,(xFov/acqEng->getnumValidXSamps()),(yFov/acqEng->getnumValidYSamps()));
}

//Function: UpdateLineRateField
//Type: Slot
//Description: Updates the linerate field and frametime if the acquisition parameters are changed
//Returns: linerate (hz)
double TwoPhotonControl::updateLineRateField()
{
	int		lineRate, numPxls, xPxls;
	double	sampRate, frameTime;

	sampRate	= scanEng->getSamp_Rate();
	xPxls		= scanEng->getTotSampsPerLine();
	numPxls		= scanEng->getNumSampsPerFrame();

	//calculate linerate and frametime
	lineRate	= sampRate / (xPxls);									//rate (Hz) = sampRate (Hz) / (numValidXSamps  )
	frameTime	= (1/sampRate) * numPxls;								//frameTime (s) = (1/sampleRate) (s/samp) * numPixels per frame

	//Set GUI values
	scanEng->setLine_Rate(lineRate);
	emit sendLineRateInfo(lineRate, frameTime);
	
	return lineRate;
}
//Function: UpdateLineScanSpeed
//Type: Slot
//Description: Updates the linescan rate field based on the scan parameters
double TwoPhotonControl::UpdateLineScanSpeed()
{
	int			numSamps;
	double		sampleRate;
	double		lineSpeed;

	//get values from GUI
	numSamps = scanEng->getWidth();
	sampleRate = scanEng->getSamp_Rate();

	lineSpeed = 1/((1/sampleRate)*numSamps);

	data2P->Header.setLineRate(lineSpeed);
	data2P->Header.setLinescanRate(lineSpeed);

	//Update field for Line Speed (Hz)
	emit sendLinescanSpeed(lineSpeed);

	return lineSpeed;
}
//Function: UpdateMemoryNeeded
//Type: Slot
//Description: Updates the field indicating the amount of disk space needed for save file
//Returns: Amount of disk space needed for save file in MB
double TwoPhotonControl::UpdateMemoryNeeded()
{
	double memNeeded; //MB
	int memPerChan;
	
	//16 bit (2 bytes) signed value for each pixel + 512 byte header
	memPerChan = scanEng->getNumSampsTotal();			//pixPerChannel
	memPerChan = (memPerChan * 2) + 512;			//bytesPerChannel

	if (acqEng->getBInput1())
		memNeeded = memPerChan;
	if (acqEng->getBInput2())
		memNeeded += memPerChan;

	memNeeded = memNeeded / 1048576;	//MB = bytes * (1/1048576 MB/byte)

	//update memory needed field
	emit sendMemNeeded(memNeeded);
	
	return memNeeded;
}

//Function: AcqCallback
//Type: Slot
//Description: Starts acquisition, passes correct continuous and linescan parameters
void TwoPhotonControl::AcqCallback(const QString & buttonName)
{
	int x1,x2,y1,y2;
	bool bLineScan = false;
	bool bContin;
	unsigned long overScan;
	ContourInfo2*	contourInfo;
	QString lineScanButton = "pushButton_linescanAcq";
	
	
	if (buttonName == lineScanButton)
	{
		bLineScan = true;
		overScan = scanEng->getOverscan_LS();
		
		//Check to see if linescan is setup correctly
                contourInfo = NIVisionContourArray[0];
		if(!contourInfo)
		{
			AddLogItem("ERROR: Linescan: No line defined!");
			emit sendMessageForPopup("Error","No Data Points Defined");
			return;
		}
		if (contourInfo->type != IMAQ_LINE)
		{
			AddLogItem("ERROR: Linescan: Line must be defined with line contour tool!");
			emit sendMessageForPopup("Error","Points must be defined with open contour tool!");
			return;
		}
		else
		{
			//Setup x,y points in data file
			//grab endpoints from line contour
			x1=contourInfo->structure.line->start.x;
			y1=contourInfo->structure.line->start.y;	
			x2=contourInfo->structure.line->end.x;
			y2=contourInfo->structure.line->end.y;
		
			//Update data class
			data2P->Header.setLsX1(x1);
			data2P->Header.setLsX2(x2);
			data2P->Header.setLsY1(y1);
			data2P->Header.setLsY2(y2);

			data2P->Header.setLineRate(data2P->Header.getLinescanRate());	//ensure linerate recorded is that of linescan
			scanEng->calcLineLengthStruct(x1,y1,x2,y2);
			data2P->Header.setLineLength(scanEng->getLineLength());			//get lineLength
		}
	}
	else
	{
		overScan = scanEng->getOverscan();
	}
	
	bContin = acqEng->getContAcq();

	//Test conditions
	if(!testXVoltageRange(bLineScan,overScan))
	{
		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\nUse lower voltages or less overscan\n");
		return;
	}

	if(!bLineScan)
                if(updateLineRateField()>2000)
		{
			AddLogItem("ERROR: Scan rate too high");
			emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
			return;
		}

	if(bLineScan)
                if(UpdateLineScanSpeed()>3000)
		{
			AddLogItem("ERROR: Scan rate too high");
                        emit sendMessageForPopup("Error","Scan rate cannot go above 3KHz\n");
			return;
		}

	//Update and lock controls
	//TwoPhotonGui::pushButton_Acquire->setEnabled(false);
	//TwoPhotonGui::pushButton_linescanAcq->setEnabled(false);
	//TwoPhotonGui::pushButton_stopAcq->setEnabled(true);
	emit sigLockControlWidgets();

	RunAcq(bContin,bLineScan);
}
//Function: RunAcq
//Description: starts a continuous acquisition, enables stop button
void TwoPhotonControl::RunAcq(bool bContinuous, bool bLineScan)
{
	//stop any scanning - parkBeam
	
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	emit sigUpdateDataFile();
	emit sigUpdateAcqEng();
	emit sigUpdateScanEng();
	emit sigUpdateZStepEng();
	emit sigUpdateAomControl();

	if(bLineScan)
	{
		data2P->Header.setLineRate(data2P->Header.getLinescanRate());	//ensure linerate recorded is that of linescan
		scanEng->calcLineLengthStruct(data2P->Header.getLsX1(),data2P->Header.getLsY1(),data2P->Header.getLsX2(),data2P->Header.getLsY2());
		data2P->Header.setLineLength(scanEng->getLineLength());			//get lineLength
	}



        acqThread->init(scanEng,acqEng,data2P,zStepEng,aomCtrl);
	acqThread->setLinescan(bLineScan);
	acqThread->setContinuous(bContinuous);
	acqThread->setLifetimeFov(false);
	
	//start acquisition
	AddLogItem("Acquisition Started");
	acqThread->start();				//This is an inherited function.  It calls the run() function of the thread class 


	
}
//Function: StopAcqCallback
//Description: Called whenever "Stop" is pressed.Stops Scanning initiated by ScanDrive
void TwoPhotonControl::StopAcqCallback()
{
	AddLogItem("Continuous Scan Stopped");
	//Reset Scan/Stop buttons
	emit sigUnlockControlWidgets();
	//TwoPhotonGui::pushButton_Scan->setEnabled(true);
	//TwoPhotonGui::pushButton_Stop->setEnabled(false);

	scanEng->stopDAQmxTask();
	if (digTaskHandle1 != 0)
	{
		DAQmxStopTask(digTaskHandle1);
		DAQmxClearTask(digTaskHandle1);
		digTaskHandle1 = 0;
	}
	//SetCtrlVal(appState->panelHandle,PANEL_ledRunning,0); NEED IMPLEMENTATION
	acqEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();
	scanEng->setScanTaskHandle(0);
}
//Function: StopContAcqCallback
//Type: Slot
//Description: Stops a continuous acquisition, enables start button
void TwoPhotonControl::StopContAcqCallback()
{
	//finish last image - so that buffers are erased properly
	acqThread->setContinuous(false);

	emit sigFinishContAcq();
}
//Function: parkBeam
//Type: Slot
//Description: Initiates beam parking scan routine
void TwoPhotonControl::parkBeam()
{
	double xVoltage;
	double yVoltage;
	int	x,y;

	int retVal;

	//read x and y pixel location from gui
	x = scanEng->getPark_X();
	y = scanEng->getPark_Y();

	//calc x and y voltage to send to galvo.
	retVal = CalcXYVoltsFromPxlVal(x, y,  xVoltage,  yVoltage);
	scanEng->setXHoldVolts(xVoltage);
	scanEng->setYHoldVolts(yVoltage);

	//Config the scan task for beam parking and start task
	scanEng->parkBeam();
}
//Function: updateIntensityScaling
//Type: Slot
//Description: Changes image intensity scaling if a horizontal slider is moved -eventually replace with histogram
void TwoPhotonControl::updateIntensityScaling(short ch1Min,short ch1Max,short ch2Min,short ch2Max)
{
	//if min is greater than or equal to max
	if(ch1Max<=ch1Min)
	{
		emit sendMessageForPopup("Intensity Scaling Error","Maximum ADC value must be greater than minimum\n"
								"Resetting to defaults.");
		ch1Min=0;
		ch1Max=32768/2;
	}


	//if min is greater than or equal to max
	if(ch2Max<=ch2Min)
	{
		emit sendMessageForPopup("Intensity Scaling Error","Maximum ADC value must be greater than minimum\n"
								"Resetting to defaults.");
		ch2Min=0;
		ch2Max=32768/2;
	}

	//Update values in two photon acquisition thread
	acqThread->setIntensityScaling(ch1Max,ch1Min,ch2Max,ch2Min);

	//Update GUI
	emit sigUpdateScalingInt(ch1Min,ch1Max,ch2Min,ch2Max);
}
//Function: updateAomTimer
//Type: Slot
//Description: Slot that is triggered when AomTimer is expired
void TwoPhotonControl::updateAomTimer()
{
	//Set aomCtrl and GUI indicators to the "AOM off" situation.
	aomCtrl->setAomOn(false);
	AomControlOff();
}
//Function: updateNumZSteps
//Type: Slot
//Description: Updates the number of z steps field if z step params are changed
void TwoPhotonControl::updateNumZSteps(double zStopPos, double zStartPos, double zStepSize)
{
	emit sigUpdateZStepField(( zStopPos - zStartPos )/zStepSize);
}

//Function: sigUpdateLifetimeAcqNum
//Type: Slot
//Description: Updates the lifetime acq number needed to synch B&H acq with this software.
void TwoPhotonControl::slotUpdateLTAcqNum(int acqNumber)
{
    lifeTimeAcqNumber = acqNumber;
}

//Function: saveImageLoc
//Type: Slot
//Description: Slot, saves current x,y,z coordinates into image location table
void TwoPhotonControl::saveImageLoc(double x, double y, double z)
{
	bool ok;
	QString text;
	QTreeWidgetItem *entry;

	text = QInputDialog::getText(0,tr("Image Location Add"),tr("Description:"), QLineEdit::Normal,text, &ok);

	if(ok)
	{

		entry = new QTreeWidgetItem();
		entry->setText(0,text);

		//var = new QVariant((double)x);
		entry->setData(1,0,x);
		entry->setData(2,0,y);
		entry->setData(3,0,z);
		//entry->setData(4,0,-1);	//-1 is a flag to slot to treat as image loc
		//entry->setData(5,0,-1);
		
		//add to list
		emit sigAddSavedLoc(entry,1);

	}
}

//Function: savePointLoc
//Type: Slot
//Description: Slot, saves current x,y,z coordinates and <x,y> pixel into image location table
void TwoPhotonControl::savePointLoc(double x, double y, double z)
{
	int xPoint, yPoint;
	bool ok;
	QString text;
	QTreeWidgetItem *entry;
	ContourInfo2*	tempContour;

        tempContour = NIVisionContourArray[0];
	
	if(!tempContour)
	{
		emit sendMessageForPopup("Error","No data point defined");
		return;
	}
	if (tempContour->type != IMAQ_POINT)
	{
		emit sendMessageForPopup("Error","Point must be defined by point tool");
		return;
	}

	xPoint = tempContour->structure.point->x;
	yPoint = tempContour->structure.point->y;

	text = QInputDialog::getText(0,tr("Image Location Add"),tr("Description:"), QLineEdit::Normal,text, &ok);

	if(ok)
	{

		entry = new QTreeWidgetItem();
		entry->setText(0,text);

		//var = new QVariant((double)x);
		entry->setData(1,0,x);
		entry->setData(2,0,y);
		entry->setData(3,0,z);
		entry->setData(4,0,xPoint);
		entry->setData(5,0,yPoint);

		//add to list
		emit sigAddSavedLoc(entry,0);		
	}

}
//Function: progressUpdate
//Type: Slot
//Description: Receives percent complete from acquisition thread
void TwoPhotonControl::progressUpdate(double percent)
{
	emit sigSendPercentComplete(percent);
}

//Function: zPosUpdate
//Type: Slot
//Description: Receives z position from acquisition thread
void TwoPhotonControl::zPosUpdate(double zPos)
{
	zStepEng->setCurrentZPos(zPos);
	emit sigSendZPos(zPos);
}

//Function: viewVisionTools
//Type: Slot
//Description: slot to hide or show vision tools
void TwoPhotonControl::viewVisionTools()
{	
	//toggle window
        emit sigToggleTools();
}
//Function: viewImageOne
//Type: Slot
//Description: slot to hide or show image one
void TwoPhotonControl::viewImageOne()
{
	//toggle window
        emit sigToggleImage1();
}
//Function: viewImageTwo
//Type: Slot
//Description: slot to hide or show image two
void TwoPhotonControl::viewImageTwo()
{
	//toggle window
        emit sigToggleImage2();
}
//Function: goToLoc
//Type: Slot
//Description: Slot, goes to selected coordinates
//Input: entry containing the location to move to, value of coarse xy step field, value of zmoveto field
void TwoPhotonControl::goToLoc(QTreeWidgetItem entry, double coarse, double zMoveTo)
{
	double x,y,z;
	int xPoint,yPoint;

	if(&entry)
	{
		//get info from entry
		x = (entry.data(1,0)).toDouble();
		y = (entry.data(2,0)).toDouble();
		z = (entry.data(3,0)).toDouble();
		xPoint = (entry.data(4,0)).toInt();
		yPoint = (entry.data(5,0)).toInt();

		//move stage to position-----------------------
		//calculate x/y delta

		x = x - stepEng->GetXPos();
		y = y - stepEng->GetYPos();
 
		if(x != 0)
		{
			emit sigSendCoarseFieldVal(abs(x));

			if(x>0)
				coarseRight(abs(x),x);
			else
				coarseLeft(abs(x),x);
		}
		if(y != 0)
		{
			emit sigSendCoarseFieldVal(abs(y));
			if(y>0)
				coarseUp(abs(y),y);
			else
				coarseDown(abs(y),y);
		}
		emit sigSendCoarseFieldVal(coarse);


		//Move Z (Updates Gui automatically) if needed
		if(z!=zStepEng->getCurrentZPos())
		{
			emit sigSendZMoveToPos(z);
			this->zMoveTo(z);
			emit sigSendZMoveToPos(zMoveTo);
		}
	}
	else
	{
		emit sendMessageForPopup("Error","Must select a saved location");
		return;
	}
}
//Function: zSetOrigin
//Type: Slot
//Description: reset z stepper coordinates
//Input: current zPosition
void TwoPhotonControl::zSetOrigin(double zPos, QTreeWidget* tree)
{
	QTreeWidgetItem *entry;
	QModelIndex index;
	int i,numItems;
	double z;


	numItems = tree->topLevelItemCount();
	
	//change all values in the saved locations list to accommodate the new origin, save to array
	for(i=0;i<numItems;i++)
	{
		entry = tree->takeTopLevelItem(i);

		z = (entry->data(3,0)).toDouble();	//3 because data is x,y,z - z is third value
		entry->setData(3,0,z-zPos);

		tree->insertTopLevelItem(i,entry);

	}

	//reinitialize z stepper 
	zStepEng->Init();

	emit sigSendZPos(0);
	emit sigSendLocTree(tree);

}
//Fucntion: StopAcq
//Type: Slot
//Description: Stops acquisition in progress
void TwoPhotonControl::stopAcq()
{
	//Mark thread execution to halt
	acqThread->stopExec();

	//unlock control widgets
	emit sigUnlockControlWidgets();

	//Disable Gui Widget
	emit setStopAcqButton(false);
}
//Function: connectZCom
//Type: Slot
//Description: Reopen serial communication with z-stepper motor
void TwoPhotonControl::connectZCom(int port)
{
	zStepEng->setPort(port);
	if(!zStepEng->OpenPort())
		emit sendMessageForPopup("Error","Z-Stepper Motor hardware not connected.\n"
										"Motor controller must be connected to Serial Port.\n\n"
										"Connect hardware and reconnect.");
}
//Function: connectXYCom
//Type: Slot
//Description: Reopen serial communication with xy-stepper motor
void TwoPhotonControl::connectXYCom(int port)
{
	stepEng->setPort(port);

	if(!stepEng->openSerialPort())
		emit sendMessageForPopup("Error","Velmex VXM Motor Controller hardware not detected.\n"
										"VXM controller must be connected to selected serial port.\n\n"
										"Connect hardware and reconnect in hardware config tab.");
}
//Function: setXYOrigin
//Type: Slot
//Description: Resets the XY stepping coordinates to current position as origin, updates all saved locations
void TwoPhotonControl::setXYOrigin(double xPos,double yPos, QTreeWidget* tree)
{
	double x,y;
	QTreeWidgetItem *entry;
	QModelIndex index;
	int i,numItems;


	numItems = tree->topLevelItemCount();
	
	//change all values in the saved locations list to accommodate the new origin, save to array
	for(i=0;i<numItems;i++)
	{
		entry = tree->takeTopLevelItem(i);

		x = (entry->data(1,0)).toDouble();
		entry->setData(1,0,x-xPos);
		y = (entry->data(2,0)).toDouble();
		entry->setData(2,0,y-yPos);

		tree->insertTopLevelItem(i,entry);

	}

	emit sigSendXPos(0);
	emit sigSendYPos(0);

	//Update widget on gui
	emit sigSendLocTree(tree);

	AddLogItem("Reset XY Coordinates");
}
//Function: coarseUp
//Type: Slot
//Description: move XY stage coarse increment in +Y direction
void TwoPhotonControl::coarseUp(double coarsefield, double yPos)
{
	double temp2;
		
	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);
		
	//--------------------------------------
	stepEng->MoveY((int)(coarsefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos+coarsefield;
	emit sigSendYPos(yPos);
}
//Function: coarseDown
//Type: Slot
//Description: move XY stage coarse increment in -Y direction
void TwoPhotonControl::coarseDown(double coarsefield, double yPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);

		
	//--------------------------------------
	stepEng->MoveY((int)(-coarsefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos-coarsefield;
	emit sigSendYPos(yPos);
}
//Function: coarseLeft
//Type: Slot
//Description: move XY stage coarse increment in -X direction
void TwoPhotonControl::coarseLeft(double coarsefield, double xPos)
{
	double temp2;
	
	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(-coarsefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos-coarsefield;
	emit sigSendXPos(xPos);
}
//Function: coarseRight
//Type: Slot
//Description: move XY stage coarse increment in +X direction
void TwoPhotonControl::coarseRight(double coarsefield, double xPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(coarsefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos+coarsefield;
	emit sigSendXPos(xPos);
}
//Function: fineUp
//Type: Slot
//Description: move XY stage coarse increment in +Y direction
void TwoPhotonControl::fineUp(double finefield, double yPos)
{
	double temp2;
		
	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveY((int)(finefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos+finefield;
	emit sigSendYPos(yPos);
}
//Function: fineDown
//Type: Slot
//Description: move XY stage coarse increment in -Y direction
void TwoPhotonControl::fineDown(double finefield, double yPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveY((int)(-finefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos-finefield;
	emit sigSendYPos(yPos);
}
//Function: fineLeft
//Type: Slot
//Description: move XY stage coarse increment in -X direction
void TwoPhotonControl::fineLeft(double finefield, double xPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(-finefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos-finefield;
	emit sigSendXPos(xPos);
}
//Function: fineRight
//Type: Slot
//Description: move XY stage coarse increment in +X direction
void TwoPhotonControl::fineRight(double finefield, double xPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(finefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos+finefield;
	emit sigSendXPos(xPos);
}
//Function: zStepUp
//Type: Slot
//Description: move stage in positive z direction
void TwoPhotonControl::zStepUp(double stepSize)
{	
	int stepSz;
	double desiredLoc;

	//update stepSize
	zStepEng->setStepSize(stepSize);	
	stepSz = zStepEng->getStepSize();

	//calculate desired position
	desiredLoc = zStepEng->getCurrentZPos() + stepSz;

	//Move stepper offset
	zStepEng->MoveTo(desiredLoc,zStepEng->getCurrentStepConvFactor());
	//zStepEng->Offset(stepSz,zStepEng->getCurrentStepConvFactor());
		
	//update GUI
	emit sigSendZPos(zStepEng->getCurrentZPos());
}
//Function: zStepDown
//Type: Slot
//Description:  move stage in negative z direction
void TwoPhotonControl::zStepDown(double stepSize)
{
	int stepSz;
	double desiredLoc;

	//update stepSize
	zStepEng->setStepSize(stepSize);
	stepSz = zStepEng->getStepSize()* -1;

	//calculate desired position
	desiredLoc = zStepEng->getCurrentZPos() + stepSz;
	
	//Move stepper offset
	zStepEng->MoveTo(desiredLoc,zStepEng->getCurrentStepConvFactor());
	//zStepEng->Offset(stepSz,zStepEng->getCurrentStepConvFactor());
	
	//update GUI
	emit sigSendZPos(zStepEng->getCurrentZPos());
}
//Function: zMoveTo
//Type: Slot
//Description:  move stage in z direction to specified position (indicated by field on gui)
void TwoPhotonControl::zMoveTo(double moveToPos)
{
	//update desired zPos
	zStepEng->setDesiredZPos(moveToPos);

	//Move to pos
	zStepEng->MoveTo(zStepEng->getDesiredZPos(),zStepEng->getCurrentStepConvFactor());
		
	//update GUI
	emit sigSendZPos(zStepEng->getCurrentZPos());
}
//Function: UpdateAomControl
//Type: Slot
//Description: Copies AOM class values from GUI, tests intensity scaling
void TwoPhotonControl::updateAomControl(AomControl* aomClass)
{
	//Update Class with Gui Values
	aomCtrl->setAomPulseRepRate(aomClass->getAomPulseRepRate());
	aomCtrl->setAomOnDuration(aomClass->getAomOnDuration());
	aomCtrl->setPulseOnTime(aomClass->getPulseOnTime());
	aomCtrl->setAOMRefOutVoltage(aomClass->getAomRefOutVoltage());
	aomCtrl->setAomChan(aomClass->getAomChan());
	aomCtrl->setAomRefOutChan(aomClass->getAomRefOutChan());
	aomCtrl->setAomVoltage(aomClass->getAomVoltage());
	aomCtrl->setIntScalingTopV(aomClass->getIntensityScalingTopV());
	aomCtrl->setIntScalingBottomV(aomClass->getIntensityScalingBottomV());
	aomCtrl->setAomContinuous(aomClass->getAomContinuous());
	aomCtrl->setAomPulsed(aomClass->getAomPulsed());
	aomCtrl->setbIntScaling(aomClass->getBIntScaling());
	aomCtrl->setAomOnVoltage(aomClass->getAomOnVoltage());

	//Ensure Aom Intensity scaling is within correct bounds
	evaluateAomIntensityScaling();
}
//Function: updateAcqControl
//Type: Slot
//Description: Copies acq class values from GUI
void TwoPhotonControl::updateAcqControl(AcqEngine acqClass)
{
	//Update Class with GUI Values
	acqEng->setDToARate(acqClass.getDToARate());
	acqEng->setAcqMax(acqClass.getAcqMax());
	acqEng->setAcqMin(acqClass.getAcqMin());
	acqEng->setAcqChan1(acqClass.getAcqChan1());								
	acqEng->setAcqChan2(acqClass.getAcqChan2());
	acqEng->setnumValidXSamps(acqClass.getnumValidXSamps());
	acqEng->setnumValidYSamps(acqClass.getnumValidYSamps());
	acqEng->setNumFrames(acqClass.getNumFrames());
	acqEng->setXPos(acqClass.getXPos());
	acqEng->setYPos(acqClass.getYPos());
	acqEng->setXOffset(acqClass.getXOffset());
	//acqEng->setOverscan(TwoPhotonGui::spinBox_OverscanSize->value());
	acqEng->setPercentOverscan(SCANENGINE_PERCENT_OVERSCAN);
	
	acqEng->setContAcq(acqClass.getContAcq());
	acqEng->setBInput1(acqClass.getBInput1());
	acqEng->setBInput2(acqClass.getBInput2());
	acqEng->setSaveData(acqClass.getSaveData());
	acqEng->setB3DAcq(acqClass.getB3DAcq());
	acqEng->setZStartPos(acqClass.getZStartPos());
	acqEng->setZStopPos(acqClass.getZStopPos());
	acqEng->setZStepSize(acqClass.getZStepSize());
	acqEng->setZPos(acqClass.getZPos());
	acqEng->setWidth(acqClass.getWidth());
	acqEng->setRepeats(acqClass.getRepeats());

	acqEng->setOverscan((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * acqEng->getnumValidXSamps()));
	acqEng->setOverscan_LS((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * acqEng->getWidth()));

	acqEng->update();

	//Update FoV and Resolution (in case num pixels was changed)
	updateScalingField();
}
//Function: updateScanControl
//Type: Slot
//Description: Copies scan class values from GUI
void TwoPhotonControl::updateScanControl(ScanEngine* scanClass)
{
	//Update Class with GUI values
	scanEng->setSamp_Rate(scanClass->getSamp_Rate());
	scanEng->setLineRate(scanClass->getLine_Rate());		
	scanEng->setLineLength(scanClass->getLineLength());
	scanEng->setWidth(scanClass->getWidth());
	scanEng->setRepeats(scanClass->getRepeats());
	scanEng->setXChan(scanClass->getXChan());										
	scanEng->setYChan(scanClass->getYChan());				
	scanEng->setnumValidXSamps(scanClass->getnumValidXSamps());
	scanEng->setnumValidYSamps(scanClass->getnumValidYSamps());
	scanEng->setNumFrames(scanClass->getNumFrames());
	scanEng->setXMinVolts(scanClass->getXMinVolts());
	scanEng->setXMaxVolts(scanClass->getXMaxVolts());
	scanEng->setYMinVolts(scanClass->getYMinVolts());
	scanEng->setYMaxVolts(scanClass->getYMaxVolts());
	scanEng->setPercentOverscan(SCANENGINE_PERCENT_OVERSCAN);
	scanEng->setMag(scanClass->getMag());		
	scanEng->setScaling(scanClass->getScaling());
	scanEng->setPark_X(scanClass->getPark_X());
	scanEng->setPark_Y(scanClass->getPark_Y());

	scanEng->setOverscan((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * scanEng->getnumValidXSamps()) );
	scanEng->setOverscan_LS((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * scanEng->getWidth()) );
	
	scanEng->setTriggered(scanClass->getTriggered());

	//update scanengine data members calculated from gui data members
	scanEng->update();

	//Update FoV and Resolution (in x/y voltages were changed)
	updateScalingField();
}
//Function: updateDataControl
//Type: Slot
//Description: Copies scan class values from GUI
void TwoPhotonControl::updateDataControl(DataFile2P dataClass)
{
	int				numValidXSamps;
	int				numValidYSamps;

	//retrieve data from other classes


	if (acqEng->getBLineScan())
	{
		numValidXSamps = (int)acqEng->getWidth();
		numValidYSamps = (int)acqEng->getRepeats();
	}
	else
	{
		numValidXSamps = (int)acqEng->getnumValidXSamps();
		numValidYSamps = (int)acqEng->getnumValidYSamps();
	}

	data2P->Header.setVersion((float)Version_Number);
	data2P->Header.setB3DAcq(acqEng->getB3DAcq());
	data2P->Header.setNumX((int)acqEng->getTotSampsPerLine());
	data2P->Header.setNumY((int)acqEng->getTotLinesPerFrame());
	data2P->Header.setValidX(numValidXSamps);
	data2P->Header.setValidY(numValidYSamps);
	data2P->Header.setNumFrames((int)acqEng->getNumFrames());
	data2P->Header.setMag(scanEng->getMag());
	data2P->Header.setXMinV((float)scanEng->getXMinVolts());
	data2P->Header.setXMaxV((float)scanEng->getXMaxVolts());
	data2P->Header.setYMinV((float)scanEng->getYMinVolts());
	data2P->Header.setYMaxV((float)scanEng->getYMaxVolts());
	data2P->Header.setZPos((float)acqEng->getZPos());
	data2P->Header.setXPos((float)acqEng->getXPos());
	data2P->Header.setYPos((float)acqEng->getYPos());
	data2P->Header.setADC_Min_Voltage((float)acqEng->getAcqMin());
	data2P->Header.setADC_Max_Voltage((float)acqEng->getAcqMax());
	//dataFile.Header.ZStep = (float)acqEngine.zStepSize;
	data2P->Header.setNumChans((int)acqEng->getNumActiveChannels());
	data2P->Header.setNumBits((int)ADC_Num_Bits);
	data2P->Header.setADC_Min_Count((int)Min_Count);
	
	data2P->Header.setLineLength((float)scanEng->getLineLength());
	data2P->Header.setLineRate((float)scanEng->getLineRate());
	data2P->Header.setObjScaling((float)scanEng->getScaling());

	data2P->setPtrData(acqEng->getAcqData());

	//Get values from GUI
	data2P->setOutputDir(dataClass.getOutputDir());
        data2P->setOutputDir2(dataClass.getOutputDir2());
	data2P->Header.setB3DAcq(dataClass.Header.getB3DAcq());

	//Update Header data used for saving
	data2P->Header.setNumX(acqEng->getTotSampsPerLine());
	data2P->Header.setNumY(acqEng->getTotLinesPerFrame());
	data2P->Header.setValidX(acqEng->getnumValidXSamps());
	data2P->Header.setValidY(acqEng->getnumValidYSamps());
	data2P->Header.setNumFrames(acqEng->getNumFrames());
	data2P->Header.setAomCtrlVoltage(aomCtrl->getAomVoltage());

	/*dataFile.Header.version = (float)Version_Number;
	dataFile.Header.Mag = (float)appState->mag ;
	dataFile.Header.XMinV = (float)scanEngine.xMinVolts;
	dataFile.Header.XMaxV = (float)scanEngine.xMaxVolts;
	dataFile.Header.YMinV = (float)scanEngine.yMinVolts;
	dataFile.Header.YMaxV = (float)scanEngine.yMaxVolts;
	dataFile.Header.ZPos = (float)acqEngine.zPos;
	dataFile.Header.XPos = (float)acqEngine.xPos;
	dataFile.Header.YPos = (float)acqEngine.yPos;
	dataFile.Header.ADC_Min_Voltage = (float)acqEngine.AcqMin;
	dataFile.Header.ADC_Max_Voltage = (float)acqEngine.AcqMax;;
	//dataFile.Header.ZStep = (float)acqEngine.zStepSize;
	dataFile.Header.NumChans = (int)acqEngine.numActiveChannels;
	dataFile.Header.NumBits = (int)ADC_Num_Bits;
	dataFile.Header.ADC_Min_Count = (int)Min_Count;
	
	dataFile.Header.lineLength = (float)scanEngine.lineLength;
	dataFile.Header.lineRate = (float)scanEngine.lineRate;
	dataFile.Header.objScaling = (float)scanEngine.ObjScaling;
	*/

	data2P->setPtrData(acqEng->getAcqData());
}

//Function: updateZStepControl
//Type: Slot
//Description: Copies z-step class values from GUI
void TwoPhotonControl::updateZStepControl(zStepperDriver zStepClass)
{
	zStepEng->setBTorqueOn(zStepClass.getBTorqueOn());
	zStepEng->setDesiredZPos(zStepClass.getDesiredZPos());
}
//Function: ParseConfig
//Type: Member Function
//Description: Parses config file placed in program directory, called "two_photon.cfg", and updates program parameters based on config
//Returns: 1 upon success
int TwoPhotonControl::ParseConfig()
{
	char line[1024];
	char *token;
	char *tempStr;
	int tempInt;
	int numObj = 0;
	int retVal;

	//open config file

	QDir binDir("..//");
	QString path = binDir.currentPath();
	path.append("/Resources/Config/two_photon.cfg");
	QFile file(path);


	//cfg = fopen("C:\\Code\\C++\\TwoPhotonApp\\TwoPhotonMake\\Resources\\Config\\two_photon.cfg", "r");
	if(!file.open(QFile::ReadOnly))
	{
		emit sendMessageForPopup("File Error","Configuration File Not Found");
		return 0;
		//goto cfg_error;
	}
	else
	{
		//iterate through config, taking line by line
		while(file.readLine(line,1024)>0)
		{
			//use string tokenizer to retrieve first token on line (key name)
			token = strtok(line," ");
			
			//If key is numObjectives
			retVal = strcmp("obj",token);
			if(retVal == 0)
			{
				tempStr = strtok(NULL," ");	//objective name

				token = strtok(NULL," ");
				tempInt = atoi(token);	//scaling value (um/V)


				emit sigAddMagEntry(numObj,tempStr,tempInt);

				numObj++;

			}
			
			//if key is xy serial port
			retVal = strcmp("xyCom",token);
			if(retVal == 0)
			{
				token = strtok(NULL," ");	
				tempInt = atoi(token);		//comPort number
				stepEng->setPort(tempInt);

				emit sigSendXYCom(tempInt);
			}

			//if key is z serial port
			retVal = strcmp("zCom",token);
			if(retVal == 0)
			{
				token = strtok(NULL," ");	
				tempInt = atoi(token);		//comPort number
				zStepEng->setPort(tempInt);
				zStepEng->setPrevPort(tempInt);

				emit sigSendZCom(tempInt);

			}
		}
	}
		
	file.close();

	//Set Gui scaling field on gui
	emit sigUpdateScaling();

	return 1;
}

//Function: CalcXYVoltsFromPxlVal
//Type: Member Function
//Description: calculates voltage values for galvos, given pixel coordinates x & y
//Returns: 1 upon success
int TwoPhotonControl::CalcXYVoltsFromPxlVal(int x, int y, double& xVolts, double& yVolts)
{
	double xVoltsPerSamp;
	double yVoltsPerSamp;
	int galvoLagPxls;


	//galvoOffsetPxls = TwoPhotonGui::spinBox_xOffset->value();

	//Calc the volts per sample for x and y.
	xVoltsPerSamp = (scanEng->getXMaxVolts() - scanEng->getXMinVolts()) /
								scanEng->getnumValidXSamps();
	yVoltsPerSamp = (scanEng->getYMaxVolts() - scanEng->getYMinVolts()) /
								scanEng->getnumValidYSamps();

	galvoLagPxls = acqEng->getXOffset();

	//Calc x an y galvo voltage levels which correspond to the selected points
	xVolts = x * xVoltsPerSamp + scanEng->getXMinVolts();
	yVolts = y * yVoltsPerSamp + scanEng->getYMinVolts();
	return 1;


}
//Function: InitLog
//Type: Member Function
//Description: Parses log file placed in program directory, called "two_photon_log.txt", loads log
//Returns: 1 upon success
int TwoPhotonControl::InitLog()
{
	char		*temp;
	FILE		*log;
	time_t		absTime;
	struct tm	*timeinfo;
	QString		*logBuff;
	char		strBuff[100];
	
	//open log file in read mode to test to see if present
	log = fopen(".\\two_photon_log.txt","r");

	//if no log file is found, create a new log file
	if(log == NULL)
		emit sendMessageForPopup("File Error","Log File Not Found\n"
								"Creating New Log File\n");
	else
		fclose(log);

	//open log file in append mode
	log = fopen(".\\two_photon_log.txt","a+");

	//append to file software executed event with timestamp

	time(&absTime);
	timeinfo = localtime(&absTime);

	fwrite("\n(",1,2,log);
	fwrite(asctime(timeinfo),1,24,log);
	fwrite(")\tTwoPhoton Started\n",1,20,log);
	fclose(log);

	log = fopen(".\\two_photon_log.txt","r");
	
	emit sigClearLog();

	while(!feof(log))
	{
		fgets(strBuff,100,log);
		logBuff = new QString(strBuff);
		if(!feof(log))
			emit sigSendLogText(*logBuff);
	}
	

	fclose(log);
	return 1;
}
//Function: AddLogItem
//Type: Member Function
//Description: Adds item to log file, updates log gui element
//Returns: 1 upon success
int TwoPhotonControl::AddLogItem(char* buff)
{
	time_t		absTime;
	struct tm	*timeinfo;
	char		strBuff[125];
	QString		*logBuff;
	FILE		*log;
	int			i;


	//create timestamp
	time(&absTime);
	timeinfo = localtime(&absTime);
	sprintf(strBuff,"(%.24s)\t",asctime(timeinfo));

	//append message
	strcat(strBuff,buff);
	strcat(strBuff,"\n");

	//add entry to log gui
	logBuff = new QString(strBuff);
	emit sigSendLogText(*logBuff);

	//add entry to log file
	log = fopen(".\\two_photon_log.txt","a+");
	
	i=0;
	while(strBuff[i] != NULL)
	{
		fwrite(&(strBuff[i]),1,1,log);
		i++;
	}

	fclose(log);

	return 1;
}
//Function: AcqDriveThread
//Type: Member Function
//Description: Primary routine for scanning and acquisition. Multithreaded
void TwoPhotonControl::AcqDriveThread(bool linescan)
{

	//lock some GUI Widgets during acquisition
	emit sigLockControlWidgets();

	//Update 2P data with some needed, but not recorded values
	data2P->Header.setNumSampsTotal(acqEng->getNumSampsTotal());
	data2P->Header.setNumSampsTotal_LS(acqEng->getNumSampsTotal_LS());
	data2P->Header.setOverscan(acqEng->getOverscan());
	data2P->Header.setOverscanLS(acqEng->getOverscan_LS());
	data2P->Header.setLinescan(linescan);
	
	acqThread->init(scanEng,acqEng,data2P,zStepEng,aomCtrl);
	acqThread->setLinescan(linescan);
	acqThread->setLifetimeFov(false);
	acqThread->setContinuous(false);
	acqThread->start();		//This is an inherited function.  It calls the run() function of the thread class
}
//Function: acqFinished
//Type: Slot
//Description: Triggered once acquisition thread exits. Reactivates GUI widgets
void TwoPhotonControl::acqFinished()
{
	emit sigUnlockControlWidgets();
	emit sigToggleAomWidgets(false);
	emit sigSendPercentComplete(0);

	stopScanBar();

}
//Function: testXVoltageRange
//Type: Member Function
//Description: Tests to see if x volts to be generated for scanning are in range, to protect galvos
//Returns: 1 if safe, 0 if out of range
int TwoPhotonControl::testXVoltageRange(bool linescan,unsigned long overScan)
{
	int				numAcqPix;
	double			acqSlope,xMaxVOs,xMinVOs;
	unsigned long	totSampsPerLine;

	//calc the num samps per line including the flyback (assumes 1 samp per pxl).
	if(linescan)
		totSampsPerLine = scanEng->getWidth()  + (2*overScan);
	else
		totSampsPerLine	=  scanEng->getnumValidXSamps() + (2*overScan);


	//if overscan is present, changed max/min voltages -If overscan px = 0; no change occurs
	numAcqPix = totSampsPerLine-(2*overScan);
	acqSlope = (scanEng->getXMaxVolts() - scanEng->getXMinVolts())/numAcqPix;	//slope for non-flyback region (V/px)
	
	xMaxVOs = scanEng->getXMaxVolts() + overScan*acqSlope;	//new max voltage with overscan
	xMinVOs = scanEng->getXMinVolts() - overScan*acqSlope;		//new min voltage with overscan

	if((xMaxVOs>MaxVolts_X)||(xMinVOs<MinVolts_X))
		return 0;
	else
		return 1;


}
//Function: AomZeroStart
//Type: Member Function
//Description: Runs at initialization of GUI to start AOM with 0 volts (laser "off")
//Returns: 1 upon success
int TwoPhotonControl::AomZeroStart()
{
	int ret;
	float zeroval = 0.0;

	ret = aomCtrl->configNiDAQ();
	aomCtrl->setAomVoltage(zeroval);
	ret = aomCtrl->makeWaveform();
	ret = aomCtrl->updateWaveform();
	ret = aomCtrl->startDAQmxTask();
	aomCtrl->setAomOn(false);
	return 1;
}
//Function: AomStop
//Type: Member Function
//Description: turns off the Aom
//Returns: 1 upon success
int TwoPhotonControl::AomStop()
{
	int ret;
	ret = aomCtrl->stopDAQmxTask();
	ret = aomCtrl->clearDAQmxTask();
	aomCtrl->setAomOn(false);
	return 1;
}
//Function: AcqLifeTime1Point
//Type: Member Function
//Description: Helper function for acqlifetimedata.  This routine just handles TCSPC measurement trigger, aom configuration
//		and holds the galvos in the correct place.  Filename is no longer needed since the TCSPC board saves the data.
//Returns: 1 upon success
int TwoPhotonControl::AcqLifeTime1Point(float xVolt, float yVolt, double aomVoltage, char FILE_NAME[])
{
	int error;
	int retval;
	TaskHandle	GalvoTaskHandle = 0;
	TaskHandle	TCSPCBoardTrigTaskHandle = 0;
	int32		sampsWritten = 0;
	uInt8		writeVal;
	//double		writeSamples[2] = {xVolt, yVolt};
	//double		trigVal = 2.0;
	char        errBuff[2048]={'\0'};

	//Make sure AOM is off to begin with.
	AomStop();  //Clears tasks and related memory


	//Calculate voltage to park beam at
	scanEng->setXHoldVolts((double)xVolt);
	scanEng->setYHoldVolts((double)yVolt);
	retval = scanEng->parkBeam();

	//Create and setup TCSPC trigger Task
	writeVal = uInt8(1);
	DAQmxErrChk(DAQmxCreateTask("TCSPCBoardTrigTask",&TCSPCBoardTrigTaskHandle));
	DAQmxErrChk(DAQmxCreateDOChan (TCSPCBoardTrigTaskHandle, TCSPC_Trig_Channel,"",DAQmx_Val_ChanPerLine));
	DAQmxErrChk(DAQmxWriteDigitalLines(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByScanNumber ,&writeVal,&sampsWritten,NULL));

        //For use with multifunction board
	//DAQmxErrChk(DAQmxCreateAOVoltageChan(TCSPCBoardTrigTaskHandle, TCSPC_Trig_Channel,"",0.0, trigVal,DAQmx_Val_Volts,NULL));
	//DAQmxErrChk(DAQmxWriteAnalogF64(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,&trigVal,NULL,NULL));
	

	//Configure aom operation to be pulsed and finite 
	emit sigUpdateAomControl();
	aomCtrl->initAomCtrl();
	aomCtrl->setAomVoltage(aomVoltage);
	emit setChkAomPulsed(true);
	emit setChkAomCont(false);
	aomCtrl->configNiDAQ();

	//Start the TCSCP measurement trig task
	DAQmxErrChk(DAQmxStartTask(TCSPCBoardTrigTaskHandle));


	//Turn the AOM on
	AomControlOn(aomVoltage);

	//TCSPC computer will do the acquisition.
	Sleep(aomCtrl->getAomOnDuration()* 1000);


	//Put AOM control back into default imaging state.
	AomStop();  //Clears tasks and related memory
	
	emit sigUpdateAomControl();		//Reinit AOM struct with new settings.
	aomCtrl->initAomCtrl();

	AomZeroStart();

	//Zero out the TCSPC start signal for next trigger event.
	writeVal = uInt8(0);
	DAQmxErrChk(DAQmxWriteDigitalLines(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,&writeVal,&sampsWritten,NULL));

        //trigVal = 0.0;
	//DAQmxErrChk(DAQmxWriteAnalogF64(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,&trigVal,NULL,NULL));

	if (GalvoTaskHandle)
	{
		DAQmxStopTask(GalvoTaskHandle);
		DAQmxClearTask(GalvoTaskHandle);
	}

	if (TCSPCBoardTrigTaskHandle)
	{
		DAQmxStopTask(TCSPCBoardTrigTaskHandle);
		DAQmxClearTask(TCSPCBoardTrigTaskHandle);
	}

	//increment lifetimeAcq counter.
	lifeTimeAcqNumber++;
        emit sigUpdateLifetimeAcqNum(lifeTimeAcqNumber);
	return 1;

Error:
	if( DAQmxFailed(error) )
	{
		if (GalvoTaskHandle)
		{
			DAQmxStopTask(GalvoTaskHandle);
                        DAQmxClearTask(GalvoTaskHandle);
		}

		if (TCSPCBoardTrigTaskHandle)
		{
			DAQmxStopTask(TCSPCBoardTrigTaskHandle);
			DAQmxClearTask(TCSPCBoardTrigTaskHandle);
		}
		DAQmxGetExtendedErrorInfo(errBuff,2048);
		emit sendMessageForPopup("DAQmx Error",errBuff);
	}
	return 0;




}
//Function: CalcNumZSteps
//Type: Member Function
//Description: Calculates the number of z steps inan acquisition
//Returns: number of Z steps in acquisition
int TwoPhotonControl::CalcNumZSteps()
{
	int numZSteps;

	numZSteps = 1 + (int)(((acqEng->getZStopPos() - acqEng->getZStartPos()) 
				/ acqEng->getZStepSize()) + 0.5);

	if (numZSteps < 1)
		numZSteps = 1;

	return numZSteps;
}
//Function: evaluateAomIntensityScaling
//Type: Member Function
//Description: Checks to ensure that Aom intensity scaling values are acceptable.
//	If not, set to default values and update GUI.
void TwoPhotonControl::evaluateAomIntensityScaling()
{
	int flag = 0;

	//Test all conditions
	if((aomCtrl->getIntensityScalingTopV() > aomCtrl->getAomMaxVoltage())||(aomCtrl->getIntensityScalingTopV() < aomCtrl->getAomMinVoltage()))
	{
		emit sendMessageForPopup("Voltage Error","Aom Top Voltage out of Aom Voltage Range\n"
					"Setting Top Aom Voltage to zero.\n");
		aomCtrl->setIntScalingTopV(0);
		flag = 1;
	}

	if((aomCtrl->getIntensityScalingBottomV() > aomCtrl->getAomMaxVoltage())||(aomCtrl->getIntensityScalingBottomV() < aomCtrl->getAomMinVoltage()))
	{
		emit sendMessageForPopup("Voltage Error","Aom Bottom Voltage out of Aom Voltage Range\n"
					"Setting Bottom Aom Voltage to zero.\n");
		aomCtrl->setIntScalingBottomV(0);
		flag = 1;
	}

	if(aomCtrl->getIntensityScalingTopV() == aomCtrl->getIntensityScalingBottomV())
	{
		emit sendMessageForPopup("Voltage Error","Aom Top Voltage cannot equal Aom Bottom Voltage\n"
					"Resetting to defaults.\n");
		aomCtrl->setIntScalingTopV(1);
		aomCtrl->setIntScalingBottomV(0);
		flag = 1;
	}

	//If flag was set, update GUI
	if(flag)
		emit sendAomIntScalingVals(aomCtrl->getIntensityScalingBottomV(), aomCtrl->getIntensityScalingTopV());
}

//Function: slotSendPort
//Type: Slot
//Description: Receives port from server class and sends it to GUI for update
void TwoPhotonControl::slotSendPort(int port)
{
	emit sigSendPort(port);
}

//Function: slotUpdateLocalNIVisionVars
//Type: Slot
//Description: Gets called when NIVision class changes any member vars
void TwoPhotonControl::slotUpdateLocalNIVisionVars(NIVisionClass* niVisionVar)
{

    this->numContours = niVisionVar->numContours;
    this->NIVisionCurr_ROI = niVisionVar->curr_roi;
    this->NIVisionContourArray = (niVisionVar->contourInfoArray);

    //Update vars needed in acqthread
    this->acqThread->setNIVisionContourInfo((this->NIVisionContourArray)[0]);


}

void TwoPhotonControl::slotUpdateROIXY(Rect rect)
{
    return;

}
