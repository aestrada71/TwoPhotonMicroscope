/*	Name: TwoPhotonControl.cpp
	Description: Master container class for two photon
	Written by: Alex Greis
	
	Functional Optical Imaging Laboratory
	Department of Biomedical Engineering
	University of Texas at Austin
	Austin, TX 78712

	Created:	9/11/2009
	Updated:
*/ 

#include "TwoPhotonControl.h"
#include <QInputDialog>
#include <QTimer>
#include <QDir>
#include "string.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "time.h"

//include 2p files for functionality
#include "2pData.h"
#include "acqengine.h"
#include "aomControl.h"
#include "scanengine.h"
#include "lifetimeacq.h"
#include "AcqThread.h"
#include "stepperDriver.h"
#include "zStepDriver.h"
#include <QTreeWidget>
#include <QInputDialog>
#include "Server.h"

/*
	NI DAQ Board Configurations (Default)

	X-galvo scan:		/dev1/ao0
	Y-galvo scan:		/dev1/ao1
	AOM Ctrl:			/dev1/ao2
	AOM Ref Out:		/dev1/ao3

	CH1 PMT:			/dev1/ai0
	CH2 PMT:			/dev1/ai1

	TCSPC Trigger:		/dev1/PFI1


*/

/*	=====================================================================================================
		Version Info:
		
		This information is important to the functioning of the read_2p() MATLAB script that
		is used to read image data generated by this program. Version number is used to ensure
		that the MATLAB script can read the data correctly.

		v2.0000			First port to Qt. Starting point for data format.

		v2.0001			Mag field in header is now written as 64 chars. Previously
						this was (erroneously) written as a float32.
						

	=====================================================================================================
*/

// Global Vars & Constants ------------------------------------------------------
double			MaxVolts_X = 5.0;	//max allowable volts for x-galvos
double			MinVolts_X = -5.0;	//max allowable volts for x-galvos
const double	TwoPhotonControl::SCANENGINE_PERCENT_OVERSCAN = 0.10;
const double	TwoPhotonControl::SCANENGINE_PERCENT_OVERSCAN_V = 0.05;
const float		TwoPhotonControl::Version_Number = 2.0001;	//****SEE ABOVE VERSION INFO
const double	TwoPhotonControl::Num_XYSteps_Per_Micron = 0.6333;
const char		TwoPhotonControl::TCSPC_Trig_Channel[] = "/Dev3/port0/line1";	//"/Dev1/ao3";		//To start TCSPC board measurement 
const char		TwoPhotonControl::Trig_Channel[] = "/Dev3/port0/line1";		
TaskHandle		digTaskHandle1;		//Task handle for sample clock task.

// -----------------------------------------------------------------------------

//Function: TwoPhotonControl
//Type: Constructor (Default)
//Description: Default constructor
TwoPhotonControl::TwoPhotonControl(QObject * parent) : QObject(parent)
{
	lifeTimeAcqNumber = 1;
}
//Function: ~TwoPhotonControl
//Type: Destructor
//Description: Destructor
TwoPhotonControl::~TwoPhotonControl()
{
	//Turn off Aom
	AomStop();
}
//Function: startScanBar
//Type: Member Function
//Description: activates scan progress indication
int TwoPhotonControl::startScanBar()
{
	scanPercent = 0;
	scanTimer->start(250);

	return 1;
}
//Function: RotateGalvos
//Type: Slot
//Description: initiates routine to drive galvos to rotate themselves. This is to
//	prevent wear on the galvanometers
void TwoPhotonControl::rotateGalvos()
{
	int retVal;
	int voltNotExceeded = 1;
	
	//Allocate memory

	retVal = scanEng->releaseMemory();
	
	//Grab memory for x waveform
	scanEng->grabRotateMemory();

	//stop any scanning - parkBeam
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	AddLogItem("Galvos Rotation Started");

	//this->updateScanEng();
	//scanEng->initScan(true,false);
	voltNotExceeded = scanEng->generateRotationWaveforms();

	if(!voltNotExceeded)
	{
		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
										"Use lower voltages or less overscan\n");
		return;
	}

	scanEng->setOverscanCalculated(false);
	scanEng->configDAQmxTask(false, false);
	scanEng->setNumSampsTotal(1000);			//because config will calculate this based on xsamps,ysamps, etc.
	scanEng->writeDAQmxTask();
	
	//Start tasks in correct order.
	scanEng->startDAQmxTask();
			

}
//Function: stopScanBar
//Type: Member Function
//Description: deactivates scan progress indication
int TwoPhotonControl::stopScanBar()
{
	scanTimer->stop();
	emit sigUpdateScanBar(0);

	return 1;
}
//Function: init
//Type: Member Function
//Description: Initializes application class
//Returns: 1 for success
int TwoPhotonControl::init()
{
	//temporary scaling - replace with histogram
	scaleMin1 = 0;
	scaleMax1 = 32768;
	scaleMin2 = 0;
	scaleMax2 = 32768;

	//define class instances
	data2P = new DataFile2P(Min_Count,Max_Count,ADC_Num_Bits,Version_Number);
	acqEng = new AcqEngine(Num_Lines_Flyback);
	aomCtrl = new AomControl;
	scanEng = new ScanEngine(Num_Lines_Flyback,SCANENGINE_PERCENT_OVERSCAN,SCANENGINE_PERCENT_OVERSCAN_V);
	stepEng = new stepperDriver;
	zStepEng = new zStepperDriver;

	//must initialize aom control, since it by default updates output
	aomCtrl->initAomCtrl();
	
	//initialize class instances
	emit sigUpdateDataFile();
	emit sigUpdateAcqEng();
	emit sigUpdateAomControl();
	emit sigUpdateScanEng();
	emit sigUpdateZStepEng();

	//set up server
	tcspcServer = new Server();
	connect(tcspcServer,SIGNAL(sendPort(int)),this,SLOT(slotSendPort(int)));
	tcspcServer->init();
	
	//parse config
	ParseConfig();

	//setup aomTimer, connect to slot
	aomTimer = new QTimer();
	connect(aomTimer, SIGNAL(timeout()), this, SLOT(updateAomTimer()));

	//setup scanTimer, connect to slot
	scanTimer = new QTimer();
	connect(scanTimer,SIGNAL(timeout()),this, SLOT(updateScanBar()));
	scanPercent = -1;

	//Init dangling pointers.
	acqEng->setAcqData(NULL);
	scanEng->setDacData(NULL);
	data2P->setPtrData(NULL);

	//open connections for VXM stepper
	if(!stepEng->LoadVXMDriver())
		emit sendMessageForPopup("Error","Velmex VXM Motor Controller drivers not detected.\n"
										"Make sure driver files are located in program directory.\n\n"
										"Copy drivers to program directory and restart program.");
	if(!stepEng->openSerialPort())
		emit sendMessageForPopup("Error","Velmex VXM Motor Controller hardware not detected.\n"
										"VXM controller must be connected to Serial Port.\n\n"
										"Connect hardware and reconnect in harware config tab.");

	acqThread = new AcqThread(ADC_Num_Bits,Min_Count,Max_Count,Version_Number,scanEng,acqEng,data2P,zStepEng,aomCtrl);
	//Connect to acqThread
	connect(acqThread,SIGNAL(acqFinished()),this,SLOT(stopAcq()));

	connect(acqThread,SIGNAL(acqFinished()),this,SLOT(acqFinished()));
	connect(acqThread,SIGNAL(sendProgress(double)),this,SLOT(progressUpdate(double)));
	connect(acqThread,SIGNAL(sigZPosChange(double)),this,SLOT(zPosUpdate(double)));


	acqEng->initAcq(false,false);
	//aomCtrl->initAomCtrl();
	scanEng->initScan(false,false);

	zStepEng->setInitialized(false);
	acqEng->setBInitialized(false);
	acqEng->setMemIsAllocated(0);
	scanEng->setBInitialized(false);
	scanEng->setMemIsAllocated(0);
	//aomCtrl->setInitialized(false);

	//Open connections for zStepEng
	if(!zStepEng->Init())
		emit sendMessageForPopup("Error","Z-Stepper Motor hardware not connected.\n"
										"Motor controller must be connected to Serial Port.\n\n"
										"Connect hardware and reconnect.");

	//Load log file
	InitLog();

	//Start AOM
	AomZeroStart();

	digTaskHandle1=0;
	
	return 1;
}
//----------------------------------------------------------------------------------------
//	Slots --------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
//Function: updateScanBar
//Description: updates scan bar during galvo scanning
void TwoPhotonControl::updateScanBar()
{
	if(scanPercent >= 1)
		scanPercent = 0;
	else
		scanPercent = scanPercent + .05;

	emit sigUpdateScanBar(scanPercent);
}
//Function: Acquire
//Type: Slot
//Description: Called whenever "Acquire" is pressed. Calls functions in order to acquire 2P data and scan
//void TwoPhotonControl::Acquire()
//{
//	//stop any scanning - parkBeam
//	scanEng->stopDAQmxTask();
//	scanEng->clearDAQmxTask();


//	if(!testXVoltageRange(false,scanEng->getOverscan()))
//	{
//		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
//								"Use lower voltages or less overscan\n");
//		return;
//	}

	//start acquisition
//	AddLogItem("Acquisition Started");
//	if(updateLineRateField()<2000)
//	{
//		startScanBar();
//		AcqDriveThread(false);
//	}
//	else
//	{
//		AddLogItem("ERROR: Scan rate too high");
//		emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
//	}
//}
//Function: ScanDrive
//Type: Slot
//Description: Called whenever "Scan" is pressed.No acquisition, only scanning. Starts scan, user must press stop to stop scan.
void TwoPhotonControl::ScanDrive()
{
	int voltNotExceeded = 1;


	//stop any scanning - parkBeam
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	AddLogItem("Continuous Scan Started");
	if(updateLineRateField()<2000)
	{
		//this->updateScanEng();
		scanEng->initScan(true,false);
		voltNotExceeded = scanEng->generateWaveForms();

		if(!voltNotExceeded)
		{
			emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
											"Use lower voltages or less overscan\n");
			return;
		}

		scanEng->setOverscanCalculated(false);
		scanEng->configDAQmxTask(false, true);
		scanEng->writeDAQmxTask();
				
		//SetCtrlVal(appState->panelHandle,PANEL_ledRunning,1); NEED IMPLEMENTATION
		//ProcessDrawEvents();

		//Setup the task which generates the sample clock.
		DAQmxCreateTask("SampleClockTask",&(digTaskHandle1));
		DAQmxCreateCOPulseChanFreq (digTaskHandle1, "/Dev1/ctr1", "SampleClock", DAQmx_Val_Hz, DAQmx_Val_Low,
																	0.1, scanEng->getSamp_Rate(), 0.5);
		DAQmxCfgImplicitTiming(digTaskHandle1,DAQmx_Val_ContSamps ,scanEng->getNumSampsPerFrame());

		//Start tasks in correct order.
		scanEng->startDAQmxTask();
		DAQmxStartTask(digTaskHandle1); 
			
		//Set Scan/Stop buttons
		emit setScanButton(false);
		emit setStopButton(true);
		//lock gui controls for scanning
		emit sigLockControlWidgets();
		emit setStopAcqButton(false);

		startScanBar();
	}
	else
	{
		AddLogItem("ERROR: Scan rate too high");
		emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
	}
}


void TwoPhotonControl::changeDir()
{}
//Function: AcqLifetimeData
//Type: Slot
//Description: Acquires lifetime data defined on previous image by NI open contour tools
void TwoPhotonControl::AcqLifetimeData()
{
	ContourInfo2*	contourInfo;
//	int				contourType;
	int				NumPts;
	int				totNumPts;
	int				i;
	int				j;
	int				l;
	int				k=0;
	int				lastIndex = 0;
//	int				foo;
	int				x, y;
	int				retVal;
	double			xVolts,yVolts;
	char			txtFileName[1024];
//	char			dataFileName[1024];
	char			temp[1024];
	char			temp1[1024];
	char			temp3[1024];
	int				nameLength;
//	bool			bMemAllocated = false;
//	ofstream		outStream;					NEED IMPLEMENTATION
//	double			xConversionFactor;
//	double			galvoLagTime = acqEng->getXOffset() / acqEng->getDToARate();			//Seconds
	int				numContours = 0;				//number of contours+1 drawn on screen
	ContourInfo2*	tempContour;
	std::ofstream	outStream;
	double			aomOnVoltage = 0.0;
	bool			ok;
	LifetimeAcq*	LTAcqPts = NULL;


	//stop any scanning - parkBeam
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	//Grab ROI info from display window in separate thread
	contourInfo = acqThread->getContourVision(1);
	if(!contourInfo)
	{
		emit sendMessageForPopup("Error","No Data Points Defined");
		goto Error;
	}
	if (contourInfo->type != IMAQ_OPEN_CONTOUR)
	{
			emit sendMessageForPopup("Error","Points must be defined with open contour tool!");
			goto Error;
	}
	
	AddLogItem("Lifetime Acquisition Started");
	
	//set pulsed, nonCW AOM
	emit setChkAomPulsed(true);
	emit setChkAomCont(false);

	//Get number of contours
	i=1;
	do
	{
		contourInfo = acqThread->getContourVision(i);
		i++;
		numContours++;
	}while((contourInfo!=NULL));
	numContours--;
	
	//calculate the total number of points across all contours
	totNumPts = 0;
	for(i = 1; i<=numContours; i++)
	{	
		
		tempContour = acqThread->getContourVision(i);
		totNumPts+= tempContour->structure.openContour->numPoints;
	}

	//Create structure to hold ROI point information.  This info will be used in
	// a text file which will document where on the image the life time data came
	// from
	LTAcqPts = new LifetimeAcq[totNumPts];
	
	//Take an image and save it for reference.--------------------------------------------------------------------------
	contourInfo = acqThread->getContourVision(1);
        emit sigChkSave(true);

	if(!testXVoltageRange(false,scanEng->getOverscan()))
	{
		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\n"
								"Use lower voltages or less overscan\n");
		return;
	}
	if(updateLineRateField()>2500)
	{
		emit sendMessageForPopup("Error","Scan rate cannot go above 2.5KHz\n");
		return;
	}

	
	//Update acquisition vars -not needed now that everything is kept up to date always
	emit sigUpdateDataFile();
	emit sigUpdateAcqEng();
	emit sigUpdateScanEng();
	UpdateLineScanSpeed();
	//emit sigUpdateZStepEng();
	emit sigUpdateAomControl();

	//lock some GUI Widgets during acquisition
	emit sigLockControlWidgets();

	acqThread->exit();
        //emit sigChkSave(true);
	acqThread->init(scanEng,acqEng,data2P,zStepEng,aomCtrl);
	acqThread->setLinescan(false);
	acqThread->setContinuous(false);
	acqThread->setLifetimeFov(true);
	acqThread->start();	
	acqThread->wait(ULONG_MAX);
	
	//Prepare TCSPC Client for acquisition ---------------------
	//tcspcServer->setData("Acq");

	//------------------------------------------------------------------------------------------------------------------
		
	//Ask user what voltage to use for the AOM.
	ok = false;

	while(!ok)
	{
		aomOnVoltage = QInputDialog::getDouble(0,tr("AOM On Voltage"),tr("Aom On Voltage:"), 0.0, -2.20, 2.20, 2, &ok);
		if(!ok)
		{
			emit sendMessageForPopup("Error","Invalid Aom Voltage");
			return;
		}
	}
	
        //Process system events to keep gui going
        QCoreApplication::processEvents();

	//Cycle through the countours
	contourInfo = acqThread->getContourVision(1);

	for(l = 1; l<=numContours; l++)
	{
		contourInfo = acqThread->getContourVision(l);
		
		NumPts = contourInfo->structure.openContour->numPoints;

		//Cycle through all points on each contour
		for(i = 0; i < NumPts; i++)
		{
			//Output message to log that lifetime data is being acquired
			sprintf(temp1,"Acquiring lifetime data for contour %i , point %i.",l,i+1);
			//QMessageBox::about(this,"Info",temp1);
			AddLogItem(temp1);
                        QCoreApplication::processEvents();

			x=contourInfo->structure.openContour->points[i].x;
			y=contourInfo->structure.openContour->points[i].y;	
			
			//Calc x an y galvo voltage levels which correspond to the selected points
			retVal = CalcXYVoltsFromPxlVal(x, y, xVolts, yVolts);

			//sprintf(str, "(%i,%i)",x, y);
			LTAcqPts[i+lastIndex].setX(x);
			LTAcqPts[i+lastIndex].setY(y);
			LTAcqPts[i+lastIndex].setXVolts((float)xVolts);
			LTAcqPts[i+lastIndex].setYVolts((float)yVolts);
                        LTAcqPts[i+lastIndex].setMeasRefNum(lifeTimeAcqNumber);;
			//Acquire and save lifetime data for current point.
			//Concat file name.
	/*		{strcpy(dataFileName, temp);		
			dataFileName[strlen(dataFileName)-4] = '\0';			//chop off the .dat suffix
			sprintf(temp3,"_LifeTime_%i.dat",k+1);					//
			strcat(dataFileName,temp3);							//Concat lifetime number.
			k++;
		
			//		-Old analog method (non photon-counting)
			//retVal = LifetimeAcq(xVolts, yVolts, scanStruct,dataFileName);
			
			//status = ConfigDAQmxTasks(xVolts, yVolts, scanStructure);
			//DAQmxStartTask(aoTaskHandle);
		}
*/
			

			//Turn AOM off briefly

			sprintf(temp3," Point # %i ",k);
			retVal = AcqLifeTime1Point((float)xVolts, (float)yVolts,aomOnVoltage, temp3);

		}
		lastIndex=i+lastIndex;
	}

	//Write out structure data to txt file.	

        //data2P->GenFileName(1);	//chan num 1?
        strcpy(temp, acqThread->getFileName());

	nameLength = strlen(temp);
	strncpy(txtFileName,temp,nameLength - 3);
	txtFileName[nameLength-3]='\0';
	strcat(txtFileName,"txt");

	
	outStream.open(txtFileName, std::ios::out);
        outStream << "Associated Image File Name " << temp << ".\n";
	outStream << "Acquired " << totNumPts << " points.\n";
	outStream << "Acquired " << numContours << " contours.\n";

	for(i = 1; i<=numContours; i++)
	{	
		tempContour = acqThread->getContourVision(i);
		outStream << "Contour #" << i << " contains " << tempContour->structure.openContour->numPoints <<" points.\n";
	}
	lastIndex = 0;
	for(j = 1; j<=numContours; j++)
	{	
		tempContour = acqThread->getContourVision(j);
		NumPts = tempContour->structure.openContour->numPoints;
                outStream << "Lifetime Acq Number, X, Y, X_Volts, Y_Volts\n";
		for(i = 0; i < NumPts; i++)
		{
                        outStream << LTAcqPts[i+lastIndex].getMeasRefNum() << " , ";
			outStream << LTAcqPts[i+lastIndex].getX() << " , ";
			outStream << LTAcqPts[i+lastIndex].getY() << " , ";
			outStream << LTAcqPts[i+lastIndex].getXVolts() << " , ";
			outStream << LTAcqPts[i+lastIndex].getYVolts() << "\n";
		}
		lastIndex = i + lastIndex;
		//insert a -1 between contours
		if(j!=numContours){}
			outStream << "-1 , -1 , -1 , -1\n";
	}
	outStream.close();
	
	if (LTAcqPts)
	{
		delete [] LTAcqPts;
		LTAcqPts = NULL;
	}
	return;

Error:

	if (LTAcqPts)
	{
		delete LTAcqPts;
		LTAcqPts = NULL;
	}
	emit sendMessageForPopup("DAQmx Error","Problem Acquiring Lifetime Data!");
	
}
//Function: StopScanDrive
//Type: Slot
//Description: Called whenever "Stop" is pressed.Stops Scanning initiated by ScanDrive
void TwoPhotonControl::StopScanDrive()
{
	AddLogItem("Continuous Scan Stopped");
	//Reset Scan/Stop buttons
	emit setScanButton(true);
	emit setStopButton(false);

	

	//unlock gui controls for scanning
	emit sigUnlockControlWidgets();

	scanEng->stopDAQmxTask();
	if (digTaskHandle1 != 0)
	{
		DAQmxStopTask(digTaskHandle1);
		DAQmxClearTask(digTaskHandle1);
		digTaskHandle1 = 0;
	}
	//SetCtrlVal(appState->panelHandle,PANEL_ledRunning,0); NEED IMPLEMENTATION
	acqEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();
	scanEng->setScanTaskHandle(0);
	
	stopScanBar();
}


//Function: AomControlOn
//Type: Slot
//Description: If user enables Aom Control
void TwoPhotonControl::AomControlOn(double voltage)
{
	int retVal;

	aomCtrl->setAomVoltage(voltage);
	aomCtrl->setAomOn(true);

	//restart Aom task with new voltage
	retVal = aomCtrl->stopDAQmxTask();
	retVal = aomCtrl->clearDAQmxTask();
	//retVal = aomCtrl->makeWaveform();  config automatically calls makeWaveform
	retVal = aomCtrl->configNiDAQ();
	retVal = aomCtrl->updateWaveform();
	retVal = aomCtrl->startDAQmxTask();
	
	
	if (aomCtrl->getAomContinuous())
	{
		//For continuous Aom operation, disable timer
		aomTimer->stop();
	}
	else
	{
		//If not continuous, reset timer and start - will trigger updateAomTimer when time is expired
		aomTimer->singleShot(aomCtrl->getAomOnDuration()*1000, this, SLOT(updateAomTimer()));			//aomTimer is in ms, *1000 for seconds
	}
	
	//SetCtrlVal (panel, PANEL_aomLed, 1);	NEED IMPLEMENTATION
	emit setAomOnButton(false);
	emit setAomOffButton(true);

	AddLogItem("AOM Control Enabled");
}




//Function: AomControlUpdate
//Type: Slot
//Description: If user changed AOM voltage amp value, and aom control is on, change output value
void TwoPhotonControl::AomControlUpdate(double voltage)
{
	aomCtrl->setAomVoltage(voltage);

	//If AOM is on, change value and update output voltage of AOMControl task
	if (aomCtrl->getAomOn())
	{
		AomControlOn(voltage);
	}
}

//Function: AomControlOff
//Type: Slot
//Description: If user turns Aom control off (sets it to zero voltage)
void TwoPhotonControl::AomControlOff()
{
	//store pulsed config
	bool pulsed = aomCtrl->getAomPulsed();

	AomStop();
	aomCtrl->setAomPulsed(false);
	AomZeroStart();

	//SetCtrlVal (panel, PANEL_aomLed, 0); NEED IMPLEMENTATION

	emit setAomOnButton(true);
	emit setAomOffButton(false);

	aomCtrl->setAomOn(false);
	AddLogItem("AOM Control Disabled");

	//restore pulsed config
	aomCtrl->setAomPulsed(pulsed);
}
//Function: UpdateScalingField
//Type: Slot
//Description: Updates resolution and scaling fields
void TwoPhotonControl::updateScalingField()
{
	double xVoltRange, yVoltRange;
	double xFov, yFov;

	//Update resolution and field of view
	xVoltRange = scanEng->getXMaxVolts() - scanEng->getXMinVolts();
	yVoltRange = scanEng->getYMaxVolts() - scanEng->getYMinVolts();

	xFov = xVoltRange*scanEng->getScaling();	// um = V*(um/V)
	yFov = yVoltRange*scanEng->getScaling();	// um = V*(um/V)

	//Update GUI
	emit sigUpdateScalingFields((int)xFov,(int)yFov,(xFov/acqEng->getnumValidXSamps()),(yFov/acqEng->getnumValidYSamps()));
}

//Function: UpdateLineRateField
//Type: Slot
//Description: Updates the linerate field and frametime if the acquisition parameters are changed
//Returns: linerate (hz)
double TwoPhotonControl::updateLineRateField()
{
	int		lineRate, numPxls, xPxls;
	double	sampRate, frameTime;

	sampRate	= scanEng->getSamp_Rate();
	xPxls		= scanEng->getTotSampsPerLine();
	numPxls		= scanEng->getNumSampsPerFrame();

	//calculate linerate and frametime
	lineRate	= sampRate / (xPxls);									//rate (Hz) = sampRate (Hz) / (numValidXSamps  )
	frameTime	= (1/sampRate) * numPxls;								//frameTime (s) = (1/sampleRate) (s/samp) * numPixels per frame

	//Set GUI values
	scanEng->setLine_Rate(lineRate);
	emit sendLineRateInfo(lineRate, frameTime);
	
	return lineRate;
}
//Function: UpdateLineScanSpeed
//Type: Slot
//Description: Updates the linescan rate field based on the scan parameters
double TwoPhotonControl::UpdateLineScanSpeed()
{
	int			numSamps;
	double		sampleRate;
	double		lineSpeed;

	//get values from GUI
	numSamps = scanEng->getWidth();
	sampleRate = scanEng->getSamp_Rate();

	lineSpeed = 1/((1/sampleRate)*numSamps);

	data2P->Header.setLineRate(lineSpeed);
	data2P->Header.setLinescanRate(lineSpeed);

	//Update field for Line Speed (Hz)
	emit sendLinescanSpeed(lineSpeed);

	return lineSpeed;
}
//Function: UpdateMemoryNeeded
//Type: Slot
//Description: Updates the field indicating the amount of disk space needed for save file
//Returns: Amount of disk space needed for save file in MB
double TwoPhotonControl::UpdateMemoryNeeded()
{
	double memNeeded; //MB
	int memPerChan;
	
	//16 bit (2 bytes) signed value for each pixel + 512 byte header
	memPerChan = scanEng->getNumSampsTotal();			//pixPerChannel
	memPerChan = (memPerChan * 2) + 512;			//bytesPerChannel

	if (acqEng->getBInput1())
		memNeeded = memPerChan;
	if (acqEng->getBInput2())
		memNeeded += memPerChan;

	memNeeded = memNeeded / 1048576;	//MB = bytes * (1/1048576 MB/byte)

	//update memory needed field
	emit sendMemNeeded(memNeeded);
	
	return memNeeded;
}

//Function: AcqCallback
//Type: Slot
//Description: Starts acquisition, passes correct continuous and linescan parameters
void TwoPhotonControl::AcqCallback(const QString & buttonName)
{
	int x1,x2,y1,y2;
	bool bLineScan = false;
	bool bContin;
	unsigned long overScan;
	ContourInfo2*	contourInfo;
	QString lineScanButton = "pushButton_linescanAcq";
	
	
	if (buttonName == lineScanButton)
	{
		bLineScan = true;
		overScan = scanEng->getOverscan_LS();
		
		//Check to see if linescan is setup correctly
		contourInfo = acqThread->getContourVision(1);
		if(!contourInfo)
		{
			AddLogItem("ERROR: Linescan: No line defined!");
			emit sendMessageForPopup("Error","No Data Points Defined");
			return;
		}
		if (contourInfo->type != IMAQ_LINE)
		{
			AddLogItem("ERROR: Linescan: Line must be defined with line contour tool!");
			emit sendMessageForPopup("Error","Points must be defined with open contour tool!");
			return;
		}
		else
		{
			//Setup x,y points in data file
			//grab endpoints from line contour
			x1=contourInfo->structure.line->start.x;
			y1=contourInfo->structure.line->start.y;	
			x2=contourInfo->structure.line->end.x;
			y2=contourInfo->structure.line->end.y;
		
			//Update data class
			data2P->Header.setLsX1(x1);
			data2P->Header.setLsX2(x2);
			data2P->Header.setLsY1(y1);
			data2P->Header.setLsY2(y2);

			data2P->Header.setLineRate(data2P->Header.getLinescanRate());	//ensure linerate recorded is that of linescan
			scanEng->calcLineLengthStruct(x1,y1,x2,y2);
			data2P->Header.setLineLength(scanEng->getLineLength());			//get lineLength
		}
	}
	else
	{
		overScan = scanEng->getOverscan();
	}
	
	bContin = acqEng->getContAcq();

	//Test conditions
	if(!testXVoltageRange(bLineScan,overScan))
	{
		emit sendMessageForPopup("Error","Voltages for X Scanning out of range\nUse lower voltages or less overscan\n");
		return;
	}

	if(!bLineScan)
		if(updateLineRateField()>2000)
		{
			AddLogItem("ERROR: Scan rate too high");
			emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
			return;
		}

	if(bLineScan)
		if(UpdateLineScanSpeed()>2000)
		{
			AddLogItem("ERROR: Scan rate too high");
			emit sendMessageForPopup("Error","Scan rate cannot go above 2KHz\n");
			return;
		}

	//Update and lock controls
	//TwoPhotonGui::pushButton_Acquire->setEnabled(false);
	//TwoPhotonGui::pushButton_linescanAcq->setEnabled(false);
	//TwoPhotonGui::pushButton_stopAcq->setEnabled(true);
	emit sigLockControlWidgets();

	RunAcq(bContin,bLineScan);
}
//Function: RunAcq
//Description: starts a continuous acquisition, enables stop button
void TwoPhotonControl::RunAcq(bool bContinuous, bool bLineScan)
{
	//stop any scanning - parkBeam
	
	scanEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();

	emit sigUpdateDataFile();
	emit sigUpdateAcqEng();
	emit sigUpdateScanEng();
	emit sigUpdateZStepEng();
	emit sigUpdateAomControl();

	if(bLineScan)
	{
		data2P->Header.setLineRate(data2P->Header.getLinescanRate());	//ensure linerate recorded is that of linescan
		scanEng->calcLineLengthStruct(data2P->Header.getLsX1(),data2P->Header.getLsY1(),data2P->Header.getLsX2(),data2P->Header.getLsY2());
		data2P->Header.setLineLength(scanEng->getLineLength());			//get lineLength
	}



	acqThread->init(scanEng,acqEng,data2P,zStepEng,aomCtrl);
	acqThread->setLinescan(bLineScan);
	acqThread->setContinuous(bContinuous);
	acqThread->setLifetimeFov(false);
	
	//start acquisition
	AddLogItem("Acquisition Started");
	acqThread->start();				//This is an inherited function.  It calls the run() function of the thread class 


	
}
//Function: StopAcqCallback
//Description: Called whenever "Stop" is pressed.Stops Scanning initiated by ScanDrive
void TwoPhotonControl::StopAcqCallback()
{
	AddLogItem("Continuous Scan Stopped");
	//Reset Scan/Stop buttons
	emit sigUnlockControlWidgets();
	//TwoPhotonGui::pushButton_Scan->setEnabled(true);
	//TwoPhotonGui::pushButton_Stop->setEnabled(false);

	scanEng->stopDAQmxTask();
	if (digTaskHandle1 != 0)
	{
		DAQmxStopTask(digTaskHandle1);
		DAQmxClearTask(digTaskHandle1);
		digTaskHandle1 = 0;
	}
	//SetCtrlVal(appState->panelHandle,PANEL_ledRunning,0); NEED IMPLEMENTATION
	acqEng->stopDAQmxTask();
	scanEng->clearDAQmxTask();
	scanEng->setScanTaskHandle(0);
}
//Function: StopContAcqCallback
//Type: Slot
//Description: Stops a continuous acquisition, enables start button
void TwoPhotonControl::StopContAcqCallback()
{
	//finish last image - so that buffers are erased properly
	acqThread->setContinuous(false);

	emit sigFinishContAcq();
}
//Function: parkBeam
//Type: Slot
//Description: Initiates beam parking scan routine
void TwoPhotonControl::parkBeam()
{
	double xVoltage;
	double yVoltage;
	int	x,y;

	int retVal;

	//read x and y pixel location from gui
	x = scanEng->getPark_X();
	y = scanEng->getPark_Y();

	//calc x and y voltage to send to galvo.
	retVal = CalcXYVoltsFromPxlVal(x, y,  xVoltage,  yVoltage);
	scanEng->setXHoldVolts(xVoltage);
	scanEng->setYHoldVolts(yVoltage);

	//Config the scan task for beam parking and start task
	scanEng->parkBeam();
}
//Function: updateIntensityScaling
//Type: Slot
//Description: Changes image intensity scaling if a horizontal slider is moved -eventually replace with histogram
void TwoPhotonControl::updateIntensityScaling(short ch1Min,short ch1Max,short ch2Min,short ch2Max)
{
	//if min is greater than or equal to max
	if(ch1Max<=ch1Min)
	{
		emit sendMessageForPopup("Intensity Scaling Error","Maximum ADC value must be greater than minimum\n"
								"Resetting to defaults.");
		ch1Min=0;
		ch1Max=32768/2;
	}


	//if min is greater than or equal to max
	if(ch2Max<=ch2Min)
	{
		emit sendMessageForPopup("Intensity Scaling Error","Maximum ADC value must be greater than minimum\n"
								"Resetting to defaults.");
		ch2Min=0;
		ch2Max=32768/2;
	}

	//Update values in two photon acquisition thread
	acqThread->setIntensityScaling(ch1Max,ch1Min,ch2Max,ch2Min);

	//Update GUI
	emit sigUpdateScalingInt(ch1Min,ch1Max,ch2Min,ch2Max);
}
//Function: updateAomTimer
//Type: Slot
//Description: Slot that is triggered when AomTimer is expired
void TwoPhotonControl::updateAomTimer()
{
	//Set aomCtrl and GUI indicators to the "AOM off" situation.
	aomCtrl->setAomOn(false);
	AomControlOff();
}
//Function: updateNumZSteps
//Type: Slot
//Description: Updates the number of z steps field if z step params are changed
void TwoPhotonControl::updateNumZSteps(double zStopPos, double zStartPos, double zStepSize)
{
	emit sigUpdateZStepField(( zStopPos - zStartPos )/zStepSize);
}

//Function: sigUpdateLifetimeAcqNum
//Type: Slot
//Description: Updates the lifetime acq number needed to synch B&H acq with this software.
void TwoPhotonControl::slotUpdateLTAcqNum(int acqNumber)
{
    lifeTimeAcqNumber = acqNumber;
}

//Function: saveImageLoc
//Type: Slot
//Description: Slot, saves current x,y,z coordinates into image location table
void TwoPhotonControl::saveImageLoc(double x, double y, double z)
{
	bool ok;
	QString text;
	QTreeWidgetItem *entry;

	text = QInputDialog::getText(0,tr("Image Location Add"),tr("Description:"), QLineEdit::Normal,text, &ok);

	if(ok)
	{

		entry = new QTreeWidgetItem();
		entry->setText(0,text);

		//var = new QVariant((double)x);
		entry->setData(1,0,x);
		entry->setData(2,0,y);
		entry->setData(3,0,z);
		//entry->setData(4,0,-1);	//-1 is a flag to slot to treat as image loc
		//entry->setData(5,0,-1);
		
		//add to list
		emit sigAddSavedLoc(entry,1);

	}
}

//Function: savePointLoc
//Type: Slot
//Description: Slot, saves current x,y,z coordinates and <x,y> pixel into image location table
void TwoPhotonControl::savePointLoc(double x, double y, double z)
{
	int xPoint, yPoint;
	bool ok;
	QString text;
	QTreeWidgetItem *entry;
	ContourInfo2*	tempContour;

	tempContour = acqThread->getContourVision(1);
	
	if(!tempContour)
	{
		emit sendMessageForPopup("Error","No data point defined");
		return;
	}
	if (tempContour->type != IMAQ_POINT)
	{
		emit sendMessageForPopup("Error","Point must be defined by point tool");
		return;
	}

	xPoint = tempContour->structure.point->x;
	yPoint = tempContour->structure.point->y;

	text = QInputDialog::getText(0,tr("Image Location Add"),tr("Description:"), QLineEdit::Normal,text, &ok);

	if(ok)
	{

		entry = new QTreeWidgetItem();
		entry->setText(0,text);

		//var = new QVariant((double)x);
		entry->setData(1,0,x);
		entry->setData(2,0,y);
		entry->setData(3,0,z);
		entry->setData(4,0,xPoint);
		entry->setData(5,0,yPoint);

		//add to list
		emit sigAddSavedLoc(entry,0);		
	}

}
//Function: progressUpdate
//Type: Slot
//Description: Receives percent complete from acquisition thread
void TwoPhotonControl::progressUpdate(double percent)
{
	emit sigSendPercentComplete(percent);
}

//Function: zPosUpdate
//Type: Slot
//Description: Receives z position from acquisition thread
void TwoPhotonControl::zPosUpdate(double zPos)
{
	zStepEng->setCurrentZPos(zPos);
	emit sigSendZPos(zPos);
}

//Function: viewVisionTools
//Type: Slot
//Description: slot to hide or show vision tools
void TwoPhotonControl::viewVisionTools()
{	
	//toggle window
	acqThread->toggleTools();
}
//Function: viewImageOne
//Type: Slot
//Description: slot to hide or show image one
void TwoPhotonControl::viewImageOne()
{
	//toggle window
	acqThread->toggleImage1();
}
//Function: viewImageTwo
//Type: Slot
//Description: slot to hide or show image two
void TwoPhotonControl::viewImageTwo()
{
	//toggle window
	acqThread->toggleImage2();
}
//Function: goToLoc
//Type: Slot
//Description: Slot, goes to selected coordinates
//Input: entry containing the location to move to, value of coarse xy step field, value of zmoveto field
void TwoPhotonControl::goToLoc(QTreeWidgetItem entry, double coarse, double zMoveTo)
{
	double x,y,z;
	int xPoint,yPoint;

	if(&entry)
	{
		//get info from entry
		x = (entry.data(1,0)).toDouble();
		y = (entry.data(2,0)).toDouble();
		z = (entry.data(3,0)).toDouble();
		xPoint = (entry.data(4,0)).toInt();
		yPoint = (entry.data(5,0)).toInt();

		//move stage to position-----------------------
		//calculate x/y delta

		x = x - stepEng->GetXPos();
		y = y - stepEng->GetYPos();
 
		if(x != 0)
		{
			emit sigSendCoarseFieldVal(abs(x));

			if(x>0)
				coarseRight(abs(x),x);
			else
				coarseLeft(abs(x),x);
		}
		if(y != 0)
		{
			emit sigSendCoarseFieldVal(abs(y));
			if(y>0)
				coarseUp(abs(y),y);
			else
				coarseDown(abs(y),y);
		}
		emit sigSendCoarseFieldVal(coarse);


		//Move Z (Updates Gui automatically) if needed
		if(z!=zStepEng->getCurrentZPos())
		{
			emit sigSendZMoveToPos(z);
			this->zMoveTo(z);
			emit sigSendZMoveToPos(zMoveTo);
		}
	}
	else
	{
		emit sendMessageForPopup("Error","Must select a saved location");
		return;
	}
}
//Function: zSetOrigin
//Type: Slot
//Description: reset z stepper coordinates
//Input: current zPosition
void TwoPhotonControl::zSetOrigin(double zPos, QTreeWidget* tree)
{
	QTreeWidgetItem *entry;
	QModelIndex index;
	int i,numItems;
	double z;


	numItems = tree->topLevelItemCount();
	
	//change all values in the saved locations list to accommodate the new origin, save to array
	for(i=0;i<numItems;i++)
	{
		entry = tree->takeTopLevelItem(i);

		z = (entry->data(3,0)).toDouble();	//3 because data is x,y,z - z is third value
		entry->setData(3,0,z-zPos);

		tree->insertTopLevelItem(i,entry);

	}

	//reinitialize z stepper 
	zStepEng->Init();

	emit sigSendZPos(0);
	emit sigSendLocTree(tree);

}
//Fucntion: StopAcq
//Type: Slot
//Description: Stops acquisition in progress
void TwoPhotonControl::stopAcq()
{
	//Mark thread execution to halt
	acqThread->stopExec();

	//unlock control widgets
	emit sigUnlockControlWidgets();

	//Disable Gui Widget
	emit setStopAcqButton(false);
}
//Function: connectZCom
//Type: Slot
//Description: Reopen serial communication with z-stepper motor
void TwoPhotonControl::connectZCom(int port)
{
	zStepEng->setPort(port);
	if(!zStepEng->OpenPort())
		emit sendMessageForPopup("Error","Z-Stepper Motor hardware not connected.\n"
										"Motor controller must be connected to Serial Port.\n\n"
										"Connect hardware and reconnect.");
}
//Function: connectXYCom
//Type: Slot
//Description: Reopen serial communication with xy-stepper motor
void TwoPhotonControl::connectXYCom(int port)
{
	stepEng->setPort(port);

	if(!stepEng->openSerialPort())
		emit sendMessageForPopup("Error","Velmex VXM Motor Controller hardware not detected.\n"
										"VXM controller must be connected to selected serial port.\n\n"
										"Connect hardware and reconnect in hardware config tab.");
}
//Function: setXYOrigin
//Type: Slot
//Description: Resets the XY stepping coordinates to current position as origin, updates all saved locations
void TwoPhotonControl::setXYOrigin(double xPos,double yPos, QTreeWidget* tree)
{
	double x,y;
	QTreeWidgetItem *entry;
	QModelIndex index;
	int i,numItems;


	numItems = tree->topLevelItemCount();
	
	//change all values in the saved locations list to accommodate the new origin, save to array
	for(i=0;i<numItems;i++)
	{
		entry = tree->takeTopLevelItem(i);

		x = (entry->data(1,0)).toDouble();
		entry->setData(1,0,x-xPos);
		y = (entry->data(2,0)).toDouble();
		entry->setData(2,0,y-yPos);

		tree->insertTopLevelItem(i,entry);

	}

	emit sigSendXPos(0);
	emit sigSendYPos(0);

	//Update widget on gui
	emit sigSendLocTree(tree);

	AddLogItem("Reset XY Coordinates");
}
//Function: coarseUp
//Type: Slot
//Description: move XY stage coarse increment in +Y direction
void TwoPhotonControl::coarseUp(double coarsefield, double yPos)
{
	double temp2;
		
	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);
		
	//--------------------------------------
	stepEng->MoveY((int)(coarsefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos+coarsefield;
	emit sigSendYPos(yPos);
}
//Function: coarseDown
//Type: Slot
//Description: move XY stage coarse increment in -Y direction
void TwoPhotonControl::coarseDown(double coarsefield, double yPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);

		
	//--------------------------------------
	stepEng->MoveY((int)(-coarsefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos-coarsefield;
	emit sigSendYPos(yPos);
}
//Function: coarseLeft
//Type: Slot
//Description: move XY stage coarse increment in -X direction
void TwoPhotonControl::coarseLeft(double coarsefield, double xPos)
{
	double temp2;
	
	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(-coarsefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos-coarsefield;
	emit sigSendXPos(xPos);
}
//Function: coarseRight
//Type: Slot
//Description: move XY stage coarse increment in +X direction
void TwoPhotonControl::coarseRight(double coarsefield, double xPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(coarsefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		coarsefield=ceil(coarsefield*stepEng->getXyStepsPerMicron());
	else
		coarsefield=floor(coarsefield*stepEng->getXyStepsPerMicron());

	coarsefield=coarsefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendCoarseFieldVal(coarsefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(coarsefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos+coarsefield;
	emit sigSendXPos(xPos);
}
//Function: fineUp
//Type: Slot
//Description: move XY stage coarse increment in +Y direction
void TwoPhotonControl::fineUp(double finefield, double yPos)
{
	double temp2;
		
	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveY((int)(finefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos+finefield;
	emit sigSendYPos(yPos);
}
//Function: fineDown
//Type: Slot
//Description: move XY stage coarse increment in -Y direction
void TwoPhotonControl::fineDown(double finefield, double yPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveY((int)(-finefield*stepEng->getXyStepsPerMicron()));

	yPos=yPos-finefield;
	emit sigSendYPos(yPos);
}
//Function: fineLeft
//Type: Slot
//Description: move XY stage coarse increment in -X direction
void TwoPhotonControl::fineLeft(double finefield, double xPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(-finefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos-finefield;
	emit sigSendXPos(xPos);
}
//Function: fineRight
//Type: Slot
//Description: move XY stage coarse increment in +X direction
void TwoPhotonControl::fineRight(double finefield, double xPos)
{
	double temp2;

	//round to nearest step-----------
	
	temp2=fmod(finefield,(1/stepEng->getXyStepsPerMicron()));
		
	if(temp2>.5)
		finefield=ceil(finefield*stepEng->getXyStepsPerMicron());
	else
		finefield=floor(finefield*stepEng->getXyStepsPerMicron());

	finefield=finefield*(1/stepEng->getXyStepsPerMicron());
	emit sigSendFineFieldVal(finefield);

		
	//--------------------------------------
	stepEng->MoveX((int)(finefield*stepEng->getXyStepsPerMicron()));

	xPos=xPos+finefield;
	emit sigSendXPos(xPos);
}
//Function: zStepUp
//Type: Slot
//Description: move stage in positive z direction
void TwoPhotonControl::zStepUp(double stepSize)
{	
	int stepSz;
	double desiredLoc;

	//update stepSize
	zStepEng->setStepSize(stepSize);	
	stepSz = zStepEng->getStepSize();

	//calculate desired position
	desiredLoc = zStepEng->getCurrentZPos() + stepSz;

	//Move stepper offset
	zStepEng->MoveTo(desiredLoc,zStepEng->getCurrentStepConvFactor());
	//zStepEng->Offset(stepSz,zStepEng->getCurrentStepConvFactor());
		
	//update GUI
	emit sigSendZPos(zStepEng->getCurrentZPos());
}
//Function: zStepDown
//Type: Slot
//Description:  move stage in negative z direction
void TwoPhotonControl::zStepDown(double stepSize)
{
	int stepSz;
	double desiredLoc;

	//update stepSize
	zStepEng->setStepSize(stepSize);
	stepSz = zStepEng->getStepSize()* -1;

	//calculate desired position
	desiredLoc = zStepEng->getCurrentZPos() + stepSz;
	
	//Move stepper offset
	zStepEng->MoveTo(desiredLoc,zStepEng->getCurrentStepConvFactor());
	//zStepEng->Offset(stepSz,zStepEng->getCurrentStepConvFactor());
	
	//update GUI
	emit sigSendZPos(zStepEng->getCurrentZPos());
}
//Function: zMoveTo
//Type: Slot
//Description:  move stage in z direction to specified position (indicated by field on gui)
void TwoPhotonControl::zMoveTo(double moveToPos)
{
	//update desired zPos
	zStepEng->setDesiredZPos(moveToPos);

	//Move to pos
	zStepEng->MoveTo(zStepEng->getDesiredZPos(),zStepEng->getCurrentStepConvFactor());
		
	//update GUI
	emit sigSendZPos(zStepEng->getCurrentZPos());
}
//Function: UpdateAomControl
//Type: Slot
//Description: Copies AOM class values from GUI, tests intensity scaling
void TwoPhotonControl::updateAomControl(AomControl* aomClass)
{
	//Update Class with Gui Values
	aomCtrl->setAomPulseRepRate(aomClass->getAomPulseRepRate());
	aomCtrl->setAomOnDuration(aomClass->getAomOnDuration());
	aomCtrl->setPulseOnTime(aomClass->getPulseOnTime());
	aomCtrl->setAOMRefOutVoltage(aomClass->getAomRefOutVoltage());
	aomCtrl->setAomChan(aomClass->getAomChan());
	aomCtrl->setAomRefOutChan(aomClass->getAomRefOutChan());
	aomCtrl->setAomVoltage(aomClass->getAomVoltage());
	aomCtrl->setIntScalingTopV(aomClass->getIntensityScalingTopV());
	aomCtrl->setIntScalingBottomV(aomClass->getIntensityScalingBottomV());
	aomCtrl->setAomContinuous(aomClass->getAomContinuous());
	aomCtrl->setAomPulsed(aomClass->getAomPulsed());
	aomCtrl->setbIntScaling(aomClass->getBIntScaling());
	aomCtrl->setAomOnVoltage(aomClass->getAomOnVoltage());

	//Ensure Aom Intensity scaling is within correct bounds
	evaluateAomIntensityScaling();
}
//Function: updateAcqControl
//Type: Slot
//Description: Copies acq class values from GUI
void TwoPhotonControl::updateAcqControl(AcqEngine acqClass)
{
	//Update Class with GUI Values
	acqEng->setDToARate(acqClass.getDToARate());
	acqEng->setAcqMax(acqClass.getAcqMax());
	acqEng->setAcqMin(acqClass.getAcqMin());
	acqEng->setAcqChan1(acqClass.getAcqChan1());								
	acqEng->setAcqChan2(acqClass.getAcqChan2());
	acqEng->setnumValidXSamps(acqClass.getnumValidXSamps());
	acqEng->setnumValidYSamps(acqClass.getnumValidYSamps());
	acqEng->setNumFrames(acqClass.getNumFrames());
	acqEng->setXPos(acqClass.getXPos());
	acqEng->setYPos(acqClass.getYPos());
	acqEng->setXOffset(acqClass.getXOffset());
	//acqEng->setOverscan(TwoPhotonGui::spinBox_OverscanSize->value());
	acqEng->setPercentOverscan(SCANENGINE_PERCENT_OVERSCAN);
	
	acqEng->setContAcq(acqClass.getContAcq());
	acqEng->setBInput1(acqClass.getBInput1());
	acqEng->setBInput2(acqClass.getBInput2());
	acqEng->setSaveData(acqClass.getSaveData());
	acqEng->setB3DAcq(acqClass.getB3DAcq());
	acqEng->setZStartPos(acqClass.getZStartPos());
	acqEng->setZStopPos(acqClass.getZStopPos());
	acqEng->setZStepSize(acqClass.getZStepSize());
	acqEng->setZPos(acqClass.getZPos());
	acqEng->setWidth(acqClass.getWidth());
	acqEng->setRepeats(acqClass.getRepeats());

	acqEng->setOverscan((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * acqEng->getnumValidXSamps()));
	acqEng->setOverscan_LS((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * acqEng->getWidth()));

	acqEng->update();

	//Update FoV and Resolution (in case num pixels was changed)
	updateScalingField();
}
//Function: updateScanControl
//Type: Slot
//Description: Copies scan class values from GUI
void TwoPhotonControl::updateScanControl(ScanEngine* scanClass)
{
	//Update Class with GUI values
	scanEng->setSamp_Rate(scanClass->getSamp_Rate());
	scanEng->setLineRate(scanClass->getLine_Rate());		
	scanEng->setLineLength(scanClass->getLineLength());
	scanEng->setWidth(scanClass->getWidth());
	scanEng->setRepeats(scanClass->getRepeats());
	scanEng->setXChan(scanClass->getXChan());										
	scanEng->setYChan(scanClass->getYChan());				
	scanEng->setnumValidXSamps(scanClass->getnumValidXSamps());
	scanEng->setnumValidYSamps(scanClass->getnumValidYSamps());
	scanEng->setNumFrames(scanClass->getNumFrames());
	scanEng->setXMinVolts(scanClass->getXMinVolts());
	scanEng->setXMaxVolts(scanClass->getXMaxVolts());
	scanEng->setYMinVolts(scanClass->getYMinVolts());
	scanEng->setYMaxVolts(scanClass->getYMaxVolts());
	scanEng->setPercentOverscan(SCANENGINE_PERCENT_OVERSCAN);
	scanEng->setMag(scanClass->getMag());		
	scanEng->setScaling(scanClass->getScaling());
	scanEng->setPark_X(scanClass->getPark_X());
	scanEng->setPark_Y(scanClass->getPark_Y());

	scanEng->setOverscan((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * scanEng->getnumValidXSamps()) );
	scanEng->setOverscan_LS((unsigned long)(SCANENGINE_PERCENT_OVERSCAN * scanEng->getWidth()) );
	
	scanEng->setTriggered(scanClass->getTriggered());

	//update scanengine data members calculated from gui data members
	scanEng->update();

	//Update FoV and Resolution (in x/y voltages were changed)
	updateScalingField();
}
//Function: updateDataControl
//Type: Slot
//Description: Copies scan class values from GUI
void TwoPhotonControl::updateDataControl(DataFile2P dataClass)
{
	int				numValidXSamps;
	int				numValidYSamps;

	//retrieve data from other classes


	if (acqEng->getBLineScan())
	{
		numValidXSamps = (int)acqEng->getWidth();
		numValidYSamps = (int)acqEng->getRepeats();
	}
	else
	{
		numValidXSamps = (int)acqEng->getnumValidXSamps();
		numValidYSamps = (int)acqEng->getnumValidYSamps();
	}

	data2P->Header.setVersion((float)Version_Number);
	data2P->Header.setB3DAcq(acqEng->getB3DAcq());
	data2P->Header.setNumX((int)acqEng->getTotSampsPerLine());
	data2P->Header.setNumY((int)acqEng->getTotLinesPerFrame());
	data2P->Header.setValidX(numValidXSamps);
	data2P->Header.setValidY(numValidYSamps);
	data2P->Header.setNumFrames((int)acqEng->getNumFrames());
	data2P->Header.setMag(scanEng->getMag());
	data2P->Header.setXMinV((float)scanEng->getXMinVolts());
	data2P->Header.setXMaxV((float)scanEng->getXMaxVolts());
	data2P->Header.setYMinV((float)scanEng->getYMinVolts());
	data2P->Header.setYMaxV((float)scanEng->getYMaxVolts());
	data2P->Header.setZPos((float)acqEng->getZPos());
	data2P->Header.setXPos((float)acqEng->getXPos());
	data2P->Header.setYPos((float)acqEng->getYPos());
	data2P->Header.setADC_Min_Voltage((float)acqEng->getAcqMin());
	data2P->Header.setADC_Max_Voltage((float)acqEng->getAcqMax());
	//dataFile.Header.ZStep = (float)acqEngine.zStepSize;
	data2P->Header.setNumChans((int)acqEng->getNumActiveChannels());
	data2P->Header.setNumBits((int)ADC_Num_Bits);
	data2P->Header.setADC_Min_Count((int)Min_Count);
	
	data2P->Header.setLineLength((float)scanEng->getLineLength());
	data2P->Header.setLineRate((float)scanEng->getLineRate());
	data2P->Header.setObjScaling((float)scanEng->getScaling());

	data2P->setPtrData(acqEng->getAcqData());

	//Get values from GUI
	data2P->setOutputDir(dataClass.getOutputDir());
	data2P->Header.setB3DAcq(dataClass.Header.getB3DAcq());

	//Update Header data used for saving
	data2P->Header.setNumX(acqEng->getTotSampsPerLine());
	data2P->Header.setNumY(acqEng->getTotLinesPerFrame());
	data2P->Header.setValidX(acqEng->getnumValidXSamps());
	data2P->Header.setValidY(acqEng->getnumValidYSamps());
	data2P->Header.setNumFrames(acqEng->getNumFrames());
	data2P->Header.setAomCtrlVoltage(aomCtrl->getAomVoltage());

	/*dataFile.Header.version = (float)Version_Number;
	dataFile.Header.Mag = (float)appState->mag ;
	dataFile.Header.XMinV = (float)scanEngine.xMinVolts;
	dataFile.Header.XMaxV = (float)scanEngine.xMaxVolts;
	dataFile.Header.YMinV = (float)scanEngine.yMinVolts;
	dataFile.Header.YMaxV = (float)scanEngine.yMaxVolts;
	dataFile.Header.ZPos = (float)acqEngine.zPos;
	dataFile.Header.XPos = (float)acqEngine.xPos;
	dataFile.Header.YPos = (float)acqEngine.yPos;
	dataFile.Header.ADC_Min_Voltage = (float)acqEngine.AcqMin;
	dataFile.Header.ADC_Max_Voltage = (float)acqEngine.AcqMax;;
	//dataFile.Header.ZStep = (float)acqEngine.zStepSize;
	dataFile.Header.NumChans = (int)acqEngine.numActiveChannels;
	dataFile.Header.NumBits = (int)ADC_Num_Bits;
	dataFile.Header.ADC_Min_Count = (int)Min_Count;
	
	dataFile.Header.lineLength = (float)scanEngine.lineLength;
	dataFile.Header.lineRate = (float)scanEngine.lineRate;
	dataFile.Header.objScaling = (float)scanEngine.ObjScaling;
	*/

	data2P->setPtrData(acqEng->getAcqData());
}

//Function: updateZStepControl
//Type: Slot
//Description: Copies z-step class values from GUI
void TwoPhotonControl::updateZStepControl(zStepperDriver zStepClass)
{
	zStepEng->setBTorqueOn(zStepClass.getBTorqueOn());
	zStepEng->setDesiredZPos(zStepClass.getDesiredZPos());
}
//Function: ParseConfig
//Type: Member Function
//Description: Parses config file placed in program directory, called "two_photon.cfg", and updates program parameters based on config
//Returns: 1 upon success
int TwoPhotonControl::ParseConfig()
{
	char line[1024];
	char *token;
	char *tempStr;
	int tempInt;
	int numObj = 0;
	int retVal;

	//open config file

	QDir binDir("..//");
	QString path = binDir.currentPath();
	path.append("/Resources/Config/two_photon.cfg");
	QFile file(path);


	//cfg = fopen("C:\\Code\\C++\\TwoPhotonApp\\TwoPhotonMake\\Resources\\Config\\two_photon.cfg", "r");
	if(!file.open(QFile::ReadOnly))
	{
		emit sendMessageForPopup("File Error","Configuration File Not Found");
		return 0;
		//goto cfg_error;
	}
	else
	{
		//iterate through config, taking line by line
		while(file.readLine(line,1024)>0)
		{
			//use string tokenizer to retrieve first token on line (key name)
			token = strtok(line," ");
			
			//If key is numObjectives
			retVal = strcmp("obj",token);
			if(retVal == 0)
			{
				tempStr = strtok(NULL," ");	//objective name

				token = strtok(NULL," ");
				tempInt = atoi(token);	//scaling value (um/V)


				emit sigAddMagEntry(numObj,tempStr,tempInt);

				numObj++;

			}
			
			//if key is xy serial port
			retVal = strcmp("xyCom",token);
			if(retVal == 0)
			{
				token = strtok(NULL," ");	
				tempInt = atoi(token);		//comPort number
				stepEng->setPort(tempInt);

				emit sigSendXYCom(tempInt);
			}

			//if key is z serial port
			retVal = strcmp("zCom",token);
			if(retVal == 0)
			{
				token = strtok(NULL," ");	
				tempInt = atoi(token);		//comPort number
				zStepEng->setPort(tempInt);
				zStepEng->setPrevPort(tempInt);

				emit sigSendZCom(tempInt);

			}
		}
	}
		
	file.close();

	//Set Gui scaling field on gui
	emit sigUpdateScaling();

	return 1;
}

//Function: CalcXYVoltsFromPxlVal
//Type: Member Function
//Description: calculates voltage values for galvos, given pixel coordinates x & y
//Returns: 1 upon success
int TwoPhotonControl::CalcXYVoltsFromPxlVal(int x, int y, double& xVolts, double& yVolts)
{
	double xVoltsPerSamp;
	double yVoltsPerSamp;
	int galvoLagPxls;


	//galvoOffsetPxls = TwoPhotonGui::spinBox_xOffset->value();

	//Calc the volts per sample for x and y.
	xVoltsPerSamp = (scanEng->getXMaxVolts() - scanEng->getXMinVolts()) /
								scanEng->getnumValidXSamps();
	yVoltsPerSamp = (scanEng->getYMaxVolts() - scanEng->getYMinVolts()) /
								scanEng->getnumValidYSamps();

	galvoLagPxls = acqEng->getXOffset();

	//Calc x an y galvo voltage levels which correspond to the selected points
	xVolts = x * xVoltsPerSamp + scanEng->getXMinVolts();
	yVolts = y * yVoltsPerSamp + scanEng->getYMinVolts();
	return 1;


}
//Function: InitLog
//Type: Member Function
//Description: Parses log file placed in program directory, called "two_photon_log.txt", loads log
//Returns: 1 upon success
int TwoPhotonControl::InitLog()
{
	char		*temp;
	FILE		*log;
	time_t		absTime;
	struct tm	*timeinfo;
	QString		*logBuff;
	char		strBuff[100];
	
	//open log file in read mode to test to see if present
	log = fopen(".\\two_photon_log.txt","r");

	//if no log file is found, create a new log file
	if(log == NULL)
		emit sendMessageForPopup("File Error","Log File Not Found\n"
								"Creating New Log File\n");
	else
		fclose(log);

	//open log file in append mode
	log = fopen(".\\two_photon_log.txt","a+");

	//append to file software executed event with timestamp

	time(&absTime);
	timeinfo = localtime(&absTime);

	fwrite("\n(",1,2,log);
	fwrite(asctime(timeinfo),1,24,log);
	fwrite(")\tTwoPhoton Started\n",1,20,log);
	fclose(log);

	log = fopen(".\\two_photon_log.txt","r");
	
	emit sigClearLog();

	while(!feof(log))
	{
		fgets(strBuff,100,log);
		logBuff = new QString(strBuff);
		if(!feof(log))
			emit sigSendLogText(*logBuff);
	}
	

	fclose(log);
	return 1;
}
//Function: AddLogItem
//Type: Member Function
//Description: Adds item to log file, updates log gui element
//Returns: 1 upon success
int TwoPhotonControl::AddLogItem(char* buff)
{
	time_t		absTime;
	struct tm	*timeinfo;
	char		strBuff[125];
	QString		*logBuff;
	FILE		*log;
	int			i;


	//create timestamp
	time(&absTime);
	timeinfo = localtime(&absTime);
	sprintf(strBuff,"(%.24s)\t",asctime(timeinfo));

	//append message
	strcat(strBuff,buff);
	strcat(strBuff,"\n");

	//add entry to log gui
	logBuff = new QString(strBuff);
	emit sigSendLogText(*logBuff);

	//add entry to log file
	log = fopen(".\\two_photon_log.txt","a+");
	
	i=0;
	while(strBuff[i] != NULL)
	{
		fwrite(&(strBuff[i]),1,1,log);
		i++;
	}

	fclose(log);

	return 1;
}
//Function: AcqDriveThread
//Type: Member Function
//Description: Primary routine for scanning and acquisition. Multithreaded
void TwoPhotonControl::AcqDriveThread(bool linescan)
{

	//lock some GUI Widgets during acquisition
	emit sigLockControlWidgets();

	//Update 2P data with some needed, but not recorded values
	data2P->Header.setNumSampsTotal(acqEng->getNumSampsTotal());
	data2P->Header.setNumSampsTotal_LS(acqEng->getNumSampsTotal_LS());
	data2P->Header.setOverscan(acqEng->getOverscan());
	data2P->Header.setOverscanLS(acqEng->getOverscan_LS());
	data2P->Header.setLinescan(linescan);
	
	acqThread->init(scanEng,acqEng,data2P,zStepEng,aomCtrl);
	acqThread->setLinescan(linescan);
	acqThread->setLifetimeFov(false);
	acqThread->setContinuous(false);
	acqThread->start();		//This is an inherited function.  It calls the run() function of the thread class
}
//Function: acqFinished
//Type: Slot
//Description: Triggered once acquisition thread exits. Reactivates GUI widgets
void TwoPhotonControl::acqFinished()
{
	emit sigUnlockControlWidgets();
	emit sigToggleAomWidgets(false);
	emit sigSendPercentComplete(0);

	stopScanBar();

}
//Function: testXVoltageRange
//Type: Member Function
//Description: Tests to see if x volts to be generated for scanning are in range, to protect galvos
//Returns: 1 if safe, 0 if out of range
int TwoPhotonControl::testXVoltageRange(bool linescan,unsigned long overScan)
{
	int				numAcqPix;
	double			acqSlope,xMaxVOs,xMinVOs;
	unsigned long	totSampsPerLine;

	//calc the num samps per line including the flyback (assumes 1 samp per pxl).
	if(linescan)
		totSampsPerLine = scanEng->getWidth()  + (2*overScan);
	else
		totSampsPerLine	=  scanEng->getnumValidXSamps() + (2*overScan);


	//if overscan is present, changed max/min voltages -If overscan px = 0; no change occurs
	numAcqPix = totSampsPerLine-(2*overScan);
	acqSlope = (scanEng->getXMaxVolts() - scanEng->getXMinVolts())/numAcqPix;	//slope for non-flyback region (V/px)
	
	xMaxVOs = scanEng->getXMaxVolts() + overScan*acqSlope;	//new max voltage with overscan
	xMinVOs = scanEng->getXMinVolts() - overScan*acqSlope;		//new min voltage with overscan

	if((xMaxVOs>MaxVolts_X)||(xMinVOs<MinVolts_X))
		return 0;
	else
		return 1;


}
//Function: AomZeroStart
//Type: Member Function
//Description: Runs at initialization of GUI to start AOM with 0 volts (laser "off")
//Returns: 1 upon success
int TwoPhotonControl::AomZeroStart()
{
	int ret;
	float zeroval = 0.0;

	ret = aomCtrl->configNiDAQ();
	aomCtrl->setAomVoltage(zeroval);
	ret = aomCtrl->makeWaveform();
	ret = aomCtrl->updateWaveform();
	ret = aomCtrl->startDAQmxTask();
	aomCtrl->setAomOn(false);
	return 1;
}
//Function: AomStop
//Type: Member Function
//Description: turns off the Aom
//Returns: 1 upon success
int TwoPhotonControl::AomStop()
{
	int ret;
	ret = aomCtrl->stopDAQmxTask();
	ret = aomCtrl->clearDAQmxTask();
	aomCtrl->setAomOn(false);
	return 1;
}
//Function: AcqLifeTime1Point
//Type: Member Function
//Description: Helper function for acqlifetimedata.  This routine just handles TCSPC measurement trigger, aom configuration
//		and holds the galvos in the correct place.  Filename is no longer needed since the TCSPC board saves the data.
//Returns: 1 upon success
int TwoPhotonControl::AcqLifeTime1Point(float xVolt, float yVolt, double aomVoltage, char FILE_NAME[])
{
	int error;
	int retval;
	TaskHandle	GalvoTaskHandle = 0;
	TaskHandle	TCSPCBoardTrigTaskHandle = 0;
	int32		sampsWritten = 0;
	uInt8		writeVal;
	//double		writeSamples[2] = {xVolt, yVolt};
	//double		trigVal = 2.0;
	char        errBuff[2048]={'\0'};

	//Make sure AOM is off to begin with.
	AomStop();  //Clears tasks and related memory

	/*
	//Create and setup Galvo Task
	DAQmxErrChk(DAQmxCreateTask("GalvoTask",&GalvoTaskHandle));
	DAQmxErrChk(DAQmxCreateAOVoltageChan(GalvoTaskHandle,scanEng->getXChan(),"",scanEng->getXMinVolts(), scanEng->getXMaxVolts(),DAQmx_Val_Volts,NULL));
	DAQmxErrChk(DAQmxCreateAOVoltageChan(GalvoTaskHandle,scanEng->getYChan(),"",scanEng->getYMinVolts(), scanEng->getYMaxVolts(),DAQmx_Val_Volts,NULL));
	DAQmxErrChk(DAQmxWriteAnalogF64(GalvoTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,writeSamples,NULL,NULL));
	DAQmxErrChk(DAQmxStartTask(GalvoTaskHandle)); //Moves galvos to correct position immediately.
	*/

	//Calculate voltage to park beam at
	scanEng->setXHoldVolts((double)xVolt);
	scanEng->setYHoldVolts((double)yVolt);
	retval = scanEng->parkBeam();

	//Create and setup TCSPC trigger Task
	writeVal = uInt8(1);
	DAQmxErrChk(DAQmxCreateTask("TCSPCBoardTrigTask",&TCSPCBoardTrigTaskHandle));
	DAQmxErrChk(DAQmxCreateDOChan (TCSPCBoardTrigTaskHandle, TCSPC_Trig_Channel,"",DAQmx_Val_ChanPerLine));
	DAQmxErrChk(DAQmxWriteDigitalLines(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByScanNumber ,&writeVal,&sampsWritten,NULL));
	//For use with multifunction board
	//DAQmxErrChk(DAQmxCreateAOVoltageChan(TCSPCBoardTrigTaskHandle, TCSPC_Trig_Channel,"",0.0, trigVal,DAQmx_Val_Volts,NULL));
	//DAQmxErrChk(DAQmxWriteAnalogF64(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,&trigVal,NULL,NULL));
	

	//Configure aom operation to be pulsed and finite 
	emit sigUpdateAomControl();
	aomCtrl->initAomCtrl();
	aomCtrl->setAomVoltage(aomVoltage);
	emit setChkAomPulsed(true);
	emit setChkAomCont(false);
	aomCtrl->configNiDAQ();

	//Start the TCSCP measurement trig task
	DAQmxErrChk(DAQmxStartTask(TCSPCBoardTrigTaskHandle));


	//Turn the AOM on
	AomControlOn(aomVoltage);

	//TCSPC computer will do the acquisition.
	Sleep(aomCtrl->getAomOnDuration()* 1000);


	//Put AOM control back into default imaging state.
	AomStop();  //Clears tasks and related memory
	
	emit sigUpdateAomControl();		//Reinit AOM struct with new settings.
	aomCtrl->initAomCtrl();

	AomZeroStart();

	//Zero out the TCSPC start signal for next trigger event.
	writeVal = uInt8(0);
	DAQmxErrChk(DAQmxWriteDigitalLines(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,&writeVal,&sampsWritten,NULL));
	//trigVal = 0.0;
	//DAQmxErrChk(DAQmxWriteAnalogF64(TCSPCBoardTrigTaskHandle,1,1,10.0,DAQmx_Val_GroupByChannel,&trigVal,NULL,NULL));

	if (GalvoTaskHandle)
	{
		DAQmxStopTask(GalvoTaskHandle);
		DAQmxClearTask(GalvoTaskHandle);
	}

	if (TCSPCBoardTrigTaskHandle)
	{
		DAQmxStopTask(TCSPCBoardTrigTaskHandle);
		DAQmxClearTask(TCSPCBoardTrigTaskHandle);
	}

	//increment lifetimeAcq counter.
	lifeTimeAcqNumber++;
        emit sigUpdateLifetimeAcqNum(lifeTimeAcqNumber);
	return 1;

Error:
	if( DAQmxFailed(error) )
	{
		if (GalvoTaskHandle)
		{
			DAQmxStopTask(GalvoTaskHandle);
                        DAQmxClearTask(GalvoTaskHandle);
		}

		if (TCSPCBoardTrigTaskHandle)
		{
			DAQmxStopTask(TCSPCBoardTrigTaskHandle);
			DAQmxClearTask(TCSPCBoardTrigTaskHandle);
		}
		DAQmxGetExtendedErrorInfo(errBuff,2048);
		emit sendMessageForPopup("DAQmx Error",errBuff);
	}
	return 0;




}
//Function: CalcNumZSteps
//Type: Member Function
//Description: Calculates the number of z steps inan acquisition
//Returns: number of Z steps in acquisition
int TwoPhotonControl::CalcNumZSteps()
{
	int numZSteps;

	numZSteps = 1 + (int)(((acqEng->getZStopPos() - acqEng->getZStartPos()) 
				/ acqEng->getZStepSize()) + 0.5);

	if (numZSteps < 1)
		numZSteps = 1;

	return numZSteps;
}
//Function: evaluateAomIntensityScaling
//Type: Member Function
//Description: Checks to ensure that Aom intensity scaling values are acceptable.
//	If not, set to default values and update GUI.
void TwoPhotonControl::evaluateAomIntensityScaling()
{
	int flag = 0;

	//Test all conditions
	if((aomCtrl->getIntensityScalingTopV() > aomCtrl->getAomMaxVoltage())||(aomCtrl->getIntensityScalingTopV() < aomCtrl->getAomMinVoltage()))
	{
		emit sendMessageForPopup("Voltage Error","Aom Top Voltage out of Aom Voltage Range\n"
					"Setting Top Aom Voltage to zero.\n");
		aomCtrl->setIntScalingTopV(0);
		flag = 1;
	}

	if((aomCtrl->getIntensityScalingBottomV() > aomCtrl->getAomMaxVoltage())||(aomCtrl->getIntensityScalingBottomV() < aomCtrl->getAomMinVoltage()))
	{
		emit sendMessageForPopup("Voltage Error","Aom Bottom Voltage out of Aom Voltage Range\n"
					"Setting Bottom Aom Voltage to zero.\n");
		aomCtrl->setIntScalingBottomV(0);
		flag = 1;
	}

	if(aomCtrl->getIntensityScalingTopV() == aomCtrl->getIntensityScalingBottomV())
	{
		emit sendMessageForPopup("Voltage Error","Aom Top Voltage cannot equal Aom Bottom Voltage\n"
					"Resetting to defaults.\n");
		aomCtrl->setIntScalingTopV(1);
		aomCtrl->setIntScalingBottomV(0);
		flag = 1;
	}

	//If flag was set, update GUI
	if(flag)
		emit sendAomIntScalingVals(aomCtrl->getIntensityScalingBottomV(), aomCtrl->getIntensityScalingTopV());
}

//Function: slotSendPort
//Type: Slot
//Description: Receives port from server class and sends it to GUI for update
void TwoPhotonControl::slotSendPort(int port)
{
	emit sigSendPort(port);
}
